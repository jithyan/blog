<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A blog on web development with React and Typescript."/><title>Optimizing React: Part 2 - Understanding Memoization</title><meta name="next-head-count" content="16"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/blog/_next/static/css/f2e8ce7a08454583.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/f2e8ce7a08454583.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/a7fa4402bacb9a02.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/a7fa4402bacb9a02.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-b4bc6d1b20a0a573.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ed62687b5581921b.js" defer=""></script><script src="/blog/_next/static/chunks/main-cb7b41c9cdc2a097.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f51201e12e7e4d94.js" defer=""></script><script src="/blog/_next/static/chunks/299-6b06e3596b88e631.js" defer=""></script><script src="/blog/_next/static/chunks/503-5f0d2c6f9d0a5f52.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-80fde88d01873cd0.js" defer=""></script><script src="/blog/_next/static/ao1_npWihaqzXY7d22P90/_buildManifest.js" defer=""></script><script src="/blog/_next/static/ao1_npWihaqzXY7d22P90/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Inter">@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZs.woff) format('woff')}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZJhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZthjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZNhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZxhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZBhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZFhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="bg-gray-900"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-lg md:text-xl font-bold underline text-teal-500 mb-20 pt-8"><a class="hover:text-sky-400" href="/blog">Home</a></h2><article id="blog-post" class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-pink-500 font-bold text-center text-6xl tracking-tighter leading-tight mx-auto md:text-left">Optimizing React: Part 2 - Understanding Memoization</h1><div class="mt-2 mb-6 text-lg text-white font-semibold"><div class="mb-1"><time dateTime="2022-09-12T20:00:00.000Z">September	13, 2022</time> |<!-- --> <span>Jithya Nanayakkara</span> |<!-- --> <span>16 min read</span></div><div><a class="text-base text-teal-500 underline hover:text-sky-400" href="#inject-comments-for-uterances">Jump to comments</a></div></div></div><section class="mx-auto max-w-md text-sm text-left text-gray-500 dark:text-gray-400 mb-2 rounded-lg"><h2 class="text-center font-semibold text-basis text-gray-700 uppercase bg-gray-50 dark:bg-gray-700 dark:text-gray-400 py-1.5 px-2.5">Table of Contents</h2><div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#a-random-number-list-generator-and-counter-example" class="underline text-gray-900 whitespace-nowrap dark:text-white">1<!-- -->. <!-- -->A Random Number List Generator and Counter Example</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#optimizing-the-example" class="underline text-gray-900 whitespace-nowrap dark:text-white">2<!-- -->. <!-- -->Optimizing the Example</a></div></div></section><div class="max-w-2xl mx-auto text-gray-300"><div class="markdown-styles_markdown__8Ahqd"><hr/>
<p>This is the second article in a series covering techniques for optimizing React&#x27;s performance by minimizing renders.</p>
<ol>
<li><a href="https://jithyan.github.io/blog/posts/understanding-renders">Part 1 - Understanding Renders</a></li>
<li>Part 2 - Understanding Memoization (this post)</li>
<li><a href="https://jithyan.github.io/blog/posts/avoiding-memoization">Part 3 - Avoiding Memoization</a></li>
</ol>
<hr/>
<p>In the <a href="https://jithyan.github.io/blog/posts/understanding-renders">previous article</a>, we covered why a component can re-render, and how variables are given new references on each render.</p>
<p>Now that we have a better understanding of the basics, we can begin to cover how we can optimize a React app.
However in order to do so, we need to actually work on an example application. The example I&#x27;m about to introduce is incredibly silly and quite long, but we need it to be a few components deep so we could systematically walk through how it could be optimized.</p>
<h2 level="2" node="[object Object]" id="a-random-number-list-generator-and-counter-example">A Random Number List Generator and Counter Example</h2>
<p>This is what our example app looks like:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/app-first-load.png" alt="Picture of example app"/></p>
<p>And it does the following:</p>
<ul>
<li>Displays a list of random numbers.</li>
<li>Each random number is styled either with a black or white background. How this is decided is by generating <em>another</em> random number, and checking if it&#x27;s even or odd.</li>
<li>We also give the user a button to click, which increments a counter.</li>
</ul>
<p>Below is the code for the above app (I&#x27;ve stripped out any CSS, for simplicity):</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">ReactDOM.render(&lt;App /&gt;, rootElement);

// The Parent component - note that it has no state
// and passes a fixed prop to RandomNumberListAndCounter
function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;RandomNumberListAndCounter length={10} /&gt;
    &lt;/div&gt;
  );
}

function RandomNumberListAndCounter({ length }) {
  const [counter, setCounter] = useState(0);
  // We keep the random number list in state, so that
  //we can control when the list of random numbers is
  //updated, independent of re-renders of the component.
  const [randomNumbers, setRandomNumbers] = useState(
    generateListOfRandomNumbers(length)
  );

  // Generate a different set of random numbers every time length changes
  useEffect(() =&gt; {
    setRandomNumbers(generateListOfRandomNumbers(length));
  }, [length]);

  const incrementOnClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  };

  // An object that is the prop to ButtonWithFooter
  // A little unusual, but sometimes you may need to pass
  // complex objects to a component
  const configProp = {
    name: &quot;Special counter incrementer&quot;,
    listLength: length,
  };

  return (
    &lt;div&gt;
      {/* Displays the counter */}
      &lt;FancyHeader counter={counter} /&gt;
      {/* Displays the styled list of random numbers */}
      &lt;FancyNumberListFormatter numberList={randomNumbers} /&gt;
      {/* Increments the counter, and shows how many random numbers are shown*/}
      &lt;ButtonWithFooter config={configProp} onClick={incrementOnClick} /&gt;
    &lt;/div&gt;
  );
}

function FancyHeader({ counter }) {
  return (
    &lt;hgroup&gt;
      &lt;h1&gt;My Special Counter&lt;/h1&gt;
      &lt;h2&gt;Clicked {counter} times.&lt;/h2&gt;
    &lt;/hgroup&gt;
  );
}

function FancyNumberListFormatter({ numberList }) {
  return (
    &lt;div&gt;
      {numberList.map((number, i) =&gt; (
        &lt;RandomlyStyledNumber number={number} key={`${number}-${i}`} /&gt;
      ))}
    &lt;/div&gt;
  );
}

function RandomlyStyledNumber({ number }) {
  const [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);

  // I&#x27;m skipping showing any styling
  const evenStyle = {};
  const oddStyle = {};

  return &lt;span style={isEven ? evenStyle : oddStyle}&gt;{number}&lt;/span&gt;;
}

function ButtonWithFooter({ config, onClick }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;button onClick={onClick}&gt;{config.name}&lt;/button&gt;
      &lt;/div&gt;
      {/* 
        Normally you wouldn&#x27;t include a footer with a button, but this is only
        for the purpose of the example 
      */}
      &lt;footer&gt;
        &lt;em&gt;Number of random numbers shown: {config.listLength}&lt;/em&gt;
      &lt;/footer&gt;
    &lt;/&gt;
  );
}</code></div></pre>
<p>The functions to generate the random numbers use the browser <code class="bg-slate-800 px-2">crypto</code> library.
I&#x27;ve written it in a way so that it&#x27;s <strong>really</strong> slow.</p>
<p>It is <strong>not important</strong> to understand how they work, I&#x27;m just including it if you&#x27;re curious:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-typescript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function getExpensiveRandomNumber() {
  return new Array(1000)
    .fill(null)
    .map(
      () =&gt; Array.from(window.crypto.getRandomValues(new Uint16Array(1000)))[0]
    )[0];
}

function generateListOfRandomNumbers(length) {
  return new Array(length).fill(null).map(getExpensiveRandomNumber);
}</code></div></pre>
<p>This is the hierarchy of the components:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/component-hierarchy.png" alt="Component Hierarchy"/></p>
<p>So how does this app perform?
To answer this question, I&#x27;m going to use the React DevTools Profiler to measure how long it takes to render all the components:</p>
<ul>
<li>I just want the <code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> to re-render, so I can do this by clicking on the
increment counter button.</li>
<li>Before clicking the counter button, I hit record on the profiler, then after I see the counter increment, I stop recording.</li>
<li>If any renders took place, the profile will spit out a flame graph of how long each component took to render.</li>
</ul>
<p><img src="/blog/assets/blog/reducing-re-renders/app-first-click.png" alt="First click"/></p>
<p><img src="/blog/assets/blog/reducing-re-renders/app-first-click-profiler.png" alt="First click profiler"/></p>
<p>A few observations about the profiler:</p>
<ol>
<li>We can see the total time it took to render <code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> and all its children was a whopping <strong>1.25 seconds</strong>!</li>
<li><code class="bg-slate-800 px-2">App</code> did not re-render (we can tell because of its gray color).</li>
<li>Even though only the text &quot;Clicked 1 times&quot; (which belongs to <code class="bg-slate-800 px-2">FancyHeader</code>) is what changed, all the child components of <code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> <em>re-rendered</em>.</li>
</ol>
<h2 level="2" node="[object Object]" id="optimizing-the-example">Optimizing the Example</h2>
<p>We desperately need to fix the slow re-rendering of the example every time we increment the counter. And we can actually do this without memoization, by using <code class="bg-slate-800 px-2">useState</code>&#x27;s <strong>initialization function</strong>.</p>
<p>Currently, every time we render the component, we&#x27;re generating and throwing away the random number list.
By passing an initialization function to <code class="bg-slate-800 px-2">useState</code>, React will only invoke the function once (on the component&#x27;s first render).</p>
<p>This is the existing problem code:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">// In RandomNumberListAndCounter:
const [randomNumbers, setRandomNumbers] = useState(
  generateListOfRandomNumbers(length)
);

// In RandomStyledNumber:
const [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);</code></div></pre>
<p>And this is the fixed code:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">// In RandomNumberListAndCounter:
const [randomNumbers, setRandomNumbers] = useState(() =&gt;
  generateListOfRandomNumbers(length)
);

// In RandomStyledNumber:
const [isEven] = useState(() =&gt; getExpensiveRandomNumber() % 2 === 0);</code></div></pre>
<blockquote>
<p>Note that when we first load the App, its initial render will still be painfully slow. But at least we can tackle slow re-renders easily.</p>
</blockquote>
<p>Let&#x27;s see how this improves the profiler result:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/profiler-init-state.png" alt="Initialize state only once"/></p>
<p>0.9ms - A dramatic improvement!</p>
<blockquote>
<p>At this point, you&#x27;d normally stop optimizing your app (unless you expect it to grow in complexity). A 0.9ms re-render time is plenty fast. However, for the sake of learning, we&#x27;re going to optimize the rest of the app.</p>
</blockquote>
<p>But notice how all the <code class="bg-slate-800 px-2">RandomlyStyledNumber</code>, <code class="bg-slate-800 px-2">ButtonWithFooter</code> and <code class="bg-slate-800 px-2">FancyNumberListFormatter</code> components continue to re-render. These renders are unnecessary given the only thing that changes is the unrelated counter text.</p>
<p>This where <code class="bg-slate-800 px-2">React.memo</code> comes in. If we pass a component into <code class="bg-slate-800 px-2">React.memo</code>, it will only re-render it if its props have changed between re-renders of its parent. Parent components can re-render all they like, but as long as the props passed to the memoized component remain the same, the cached React Elements will be what&#x27;s returned.</p>
<p>This is how we call <code class="bg-slate-800 px-2">React.memo</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const MyComponentMemoized = React.memo(MyComponent);

// and use it like a regular component in JSX:
&lt;MyComponentMemoized /&gt;;</code></div></pre>
<p>So should we wrap all our components in the example with <code class="bg-slate-800 px-2">React.memo</code>?</p>
<p>No. It&#x27;s neither necessary nor optimal.</p>
<p>Let&#x27;s take another look at the component hierarchy diagram:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/component-hierarchy.png" alt="Component Hierarchy"/></p>
<p>From both the code and the component hierarchy, we can see that memoizing the following components would be redundant:</p>
<ul>
<li><code class="bg-slate-800 px-2">App</code>: This is the root component. It&#x27;s pointless memoizing this as it has no parent component to trigger any re-renders.</li>
<li><code class="bg-slate-800 px-2">RandomNumberListAndCounter</code>: In the context of our example, this component will only re-render when its state, <code class="bg-slate-800 px-2">counter</code>, changes. Its parent component, <code class="bg-slate-800 px-2">App</code>, doesn&#x27;t also have any state so it would never re-render. Therefore wrapping it with <code class="bg-slate-800 px-2">React.memo</code> is redundant, as memoized components will continue to re-render when its internal state or context changes (which is what we want).</li>
<li><code class="bg-slate-800 px-2">RandomlyStyledNumber</code>: This component will <strong>only</strong> re-render when its <em>parent</em>, <code class="bg-slate-800 px-2">FancyNumberListFormatter</code>, re-renders. Therefore, only memoizing its parent is sufficient.</li>
<li><code class="bg-slate-800 px-2">FancyHeader</code>: This component depends on <code class="bg-slate-800 px-2">counter</code>, as it&#x27;s passed as a prop. We know that the only thing in our app that triggers a re-render is the <code class="bg-slate-800 px-2">counter</code> being incremented. Therefore, wrapping this in <code class="bg-slate-800 px-2">React.memo</code> is redundant - because calling a memoized <code class="bg-slate-800 px-2">FancyHeader</code> with an incremented <code class="bg-slate-800 px-2">counter</code> prop will trigger a re-render since the props have changed.</li>
</ul>
<p>So only these 2 components would benefit from <code class="bg-slate-800 px-2">memo</code>:</p>
<ol>
<li><code class="bg-slate-800 px-2">FancyNumberListFormatter</code></li>
<li><code class="bg-slate-800 px-2">ButtonWithFooter</code></li>
</ol>
<p>Both of the above components only depend on the <code class="bg-slate-800 px-2">length</code> prop, and do not care about <code class="bg-slate-800 px-2">counter</code>. When <code class="bg-slate-800 px-2">counter</code> changes, these components end up re-rendering, so they&#x27;re good candidates for memoization.</p>
<p>Let&#x27;s go ahead and do just that:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">/** First change - wrap our existing components with memo: **/
const FancyNumberListFormatterMemoized = React.memo(FancyNumberListFormatter);
const ButtonWithFooterMemoized = React.memo(ButtonWithFooter);

function RandomNumberListAndCounter({ length }: { length: number }) {
  const [counter, setCounter] = useState(0);
  const [randomNumbers, setRandomNumbers] = useState(() =&gt;
    generateListOfRandomNumbers(length)
  );

  useEffect(() =&gt; {
    setRandomNumbers(generateListOfRandomNumbers(length));
  }, [length]);

  const incrementOnClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  };

  const configProp = {
    name: &quot;Special counter incrementer&quot;,
    listLength: length,
  };

  return (
    &lt;div&gt;
      &lt;FancyHeader counter={counter} /&gt;
      {/** Then we use the memoized components: **/}
      &lt;FancyNumberListFormatterMemoized numberList={randomNumbers} /&gt;
      &lt;ButtonWithFooterMemoized
        config={configProp}
        onClick={incrementOnClick}
      /&gt;
    &lt;/div&gt;
  );
}</code></div></pre>
<p>Before we check the profiler, I&#x27;m going to throttle my CPU speed by 6x in Chrome - so that it simulates users who don&#x27;t have a developer grade laptop:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/throttle-cpu.png" alt="How to throttle CPU"/></p>
<p>And now let&#x27;s take a look at the React profiler, where I measure what happens after I click the counter button:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/memo-flamegraph.png" alt="Flamegraph of memoized components"/></p>
<p>Looking good - all components that don&#x27;t need to re-render aren&#x27;t rendering according to this flamegraph (indicated by the grayed out bars).</p>
<p>But the flamegraph isn&#x27;t showing all the re-rendering components, so let&#x27;s switch views to &quot;Ranking&quot;:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/memo-ranked.png" alt="Ranking of memoized components"/></p>
<p>Only two components <em>should</em> re-render: <code class="bg-slate-800 px-2">RandomNumberListFormatter</code> and <code class="bg-slate-800 px-2">FancyHeader</code>. <code class="bg-slate-800 px-2">RandomNumberListFormatter</code> contains the state <code class="bg-slate-800 px-2">counter</code>, which changes, and <code class="bg-slate-800 px-2">FancyHeader</code> takes in the prop <code class="bg-slate-800 px-2">counter</code>.</p>
<p>But it also looks like <code class="bg-slate-800 px-2">ButtonWithFooter</code> is re-rendering, even though its props doesn&#x27;t include the <code class="bg-slate-800 px-2">counter</code> value.</p>
<p>So why would <code class="bg-slate-800 px-2">ButtonWithFooter</code> re-render despite being memoized and having no props change?</p>
<p>Allow me to yank out the cause of this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">// New object assignment
const incrementOnClick = () =&gt; {
  setCounter((prev) =&gt; prev + 1);
};

// New object assignment
const configProp = {
  name: &quot;Special counter incrementer&quot;,
  listLength: length,
};

// Even though semantically the same, config and incrementOnClick
// are different objects on each render
&lt;ButtonWithFooterMemoized config={configProp} onClick={incrementOnClick} /&gt;;</code></div></pre>
<p>The thing to note is that when <code class="bg-slate-800 px-2">React.memo</code> compares the previous props with the new props, it uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a> to compare
if they&#x27;ve changed. This is a shallow comparison - so two objects that have the same values but different memory references,
are not equal (remember <code class="bg-slate-800 px-2">{} === {}</code> evaluates to <code class="bg-slate-800 px-2">false</code>).</p>
<p>And in our example, we&#x27;re creating <strong>new objects</strong> for <code class="bg-slate-800 px-2">incrementOnClick</code> and <code class="bg-slate-800 px-2">configProp</code> on <em>every render</em>.</p>
<p>We can easily fix this by using <code class="bg-slate-800 px-2">useMemo</code>, to cache the object references:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const incrementOnClick = useMemo(
  () =&gt; () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  },
  []
);

/**
 * We only create a new object when the `length` changes.
 */
const configProp = useMemo(
  () =&gt; ({
    name: &quot;Special counter incrementer&quot;,
    listLength: length,
  }),
  [length]
);</code></div></pre>
<p>And the new Ranked profiler result is:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/profiler-usememo.png" alt="Profiler after useMemo"/></p>
<p>Now only the two expected components re-render.</p>
<p>But... notice the awkward syntax for the cached <code class="bg-slate-800 px-2">incrementOnClick</code>. We want to cache the function itself, not what it returns.
<code class="bg-slate-800 px-2">useMemo</code> accepts a function, and caches <em>the result</em> of that function. So to get around that, we pass in a function, that <code class="bg-slate-800 px-2">returns</code>
the function whose reference we want cached.</p>
<p>Instead, we can use <code class="bg-slate-800 px-2">useCallback</code> instead of <code class="bg-slate-800 px-2">useMemo</code> - its explicit purpose is to cache callback (i.e. function) references:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const incrementOnClick = useCallback(() =&gt; {
  setCounter((prev) =&gt; prev + 1);
}, []);</code></div></pre>
<p>Now that we understand how to use memoization in React, in the <a href="https://jithyan.github.io/blog/posts/avoiding-memoization">next article</a>, I&#x27;m going to cover how we can <em>avoid</em> memoization!</p></div></div><section><div id="inject-comments-for-uterances"></div></section></article></div></main></div><footer class="bg-slate-800"><div style="display:table" class="mx-auto"><ul class="list-none flex flex-row text-lg text-teal-500 underline font-semibold p-2"><li class="mr-4 max-w-md"><a href="https://github.com/jithyan" class="hover:text-sky-400 " target="_blank">Github</a></li><li class="mr-4 max-w-md"><a href="https://www.linkedin.com/in/jithyan/" class=" hover:text-sky-400 " target="_blank">LinkedIn</a></li><li class=""><a href="https://jithyan.github.io/resume/" class=" hover:text-sky-400" target="_blank">Resume</a></li></ul></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Optimizing React: Part 2 - Understanding Memoization","date":"2022-09-12T20:00:00.000Z","slug":"understanding-memoization","author":{"name":"Jithya Nanayakkara"},"content":"\n---\n\nThis is the second article in a series covering techniques for optimizing React's performance by minimizing renders.\n\n1. [Part 1 - Understanding Renders](https://jithyan.github.io/blog/posts/understanding-renders)\n2. Part 2 - Understanding Memoization (this post)\n3. [Part 3 - Avoiding Memoization](https://jithyan.github.io/blog/posts/avoiding-memoization)\n\n---\n\nIn the [previous article](https://jithyan.github.io/blog/posts/understanding-renders), we covered why a component can re-render, and how variables are given new references on each render.\n\nNow that we have a better understanding of the basics, we can begin to cover how we can optimize a React app.\nHowever in order to do so, we need to actually work on an example application. The example I'm about to introduce is incredibly silly and quite long, but we need it to be a few components deep so we could systematically walk through how it could be optimized.\n\n## A Random Number List Generator and Counter Example\n\nThis is what our example app looks like:\n\n![Picture of example app](/blog/assets/blog/reducing-re-renders/app-first-load.png)\n\nAnd it does the following:\n\n- Displays a list of random numbers.\n- Each random number is styled either with a black or white background. How this is decided is by generating _another_ random number, and checking if it's even or odd.\n- We also give the user a button to click, which increments a counter.\n\nBelow is the code for the above app (I've stripped out any CSS, for simplicity):\n\n```jsx\nReactDOM.render(\u003cApp /\u003e, rootElement);\n\n// The Parent component - note that it has no state\n// and passes a fixed prop to RandomNumberListAndCounter\nfunction App() {\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cRandomNumberListAndCounter length={10} /\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction RandomNumberListAndCounter({ length }) {\n  const [counter, setCounter] = useState(0);\n  // We keep the random number list in state, so that\n  //we can control when the list of random numbers is\n  //updated, independent of re-renders of the component.\n  const [randomNumbers, setRandomNumbers] = useState(\n    generateListOfRandomNumbers(length)\n  );\n\n  // Generate a different set of random numbers every time length changes\n  useEffect(() =\u003e {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  const incrementOnClick = () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  };\n\n  // An object that is the prop to ButtonWithFooter\n  // A little unusual, but sometimes you may need to pass\n  // complex objects to a component\n  const configProp = {\n    name: \"Special counter incrementer\",\n    listLength: length,\n  };\n\n  return (\n    \u003cdiv\u003e\n      {/* Displays the counter */}\n      \u003cFancyHeader counter={counter} /\u003e\n      {/* Displays the styled list of random numbers */}\n      \u003cFancyNumberListFormatter numberList={randomNumbers} /\u003e\n      {/* Increments the counter, and shows how many random numbers are shown*/}\n      \u003cButtonWithFooter config={configProp} onClick={incrementOnClick} /\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction FancyHeader({ counter }) {\n  return (\n    \u003chgroup\u003e\n      \u003ch1\u003eMy Special Counter\u003c/h1\u003e\n      \u003ch2\u003eClicked {counter} times.\u003c/h2\u003e\n    \u003c/hgroup\u003e\n  );\n}\n\nfunction FancyNumberListFormatter({ numberList }) {\n  return (\n    \u003cdiv\u003e\n      {numberList.map((number, i) =\u003e (\n        \u003cRandomlyStyledNumber number={number} key={`${number}-${i}`} /\u003e\n      ))}\n    \u003c/div\u003e\n  );\n}\n\nfunction RandomlyStyledNumber({ number }) {\n  const [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);\n\n  // I'm skipping showing any styling\n  const evenStyle = {};\n  const oddStyle = {};\n\n  return \u003cspan style={isEven ? evenStyle : oddStyle}\u003e{number}\u003c/span\u003e;\n}\n\nfunction ButtonWithFooter({ config, onClick }) {\n  return (\n    \u003c\u003e\n      \u003cdiv\u003e\n        \u003cbutton onClick={onClick}\u003e{config.name}\u003c/button\u003e\n      \u003c/div\u003e\n      {/* \n        Normally you wouldn't include a footer with a button, but this is only\n        for the purpose of the example \n      */}\n      \u003cfooter\u003e\n        \u003cem\u003eNumber of random numbers shown: {config.listLength}\u003c/em\u003e\n      \u003c/footer\u003e\n    \u003c/\u003e\n  );\n}\n```\n\nThe functions to generate the random numbers use the browser `crypto` library.\nI've written it in a way so that it's **really** slow.\n\nIt is **not important** to understand how they work, I'm just including it if you're curious:\n\n```typescript\nfunction getExpensiveRandomNumber() {\n  return new Array(1000)\n    .fill(null)\n    .map(\n      () =\u003e Array.from(window.crypto.getRandomValues(new Uint16Array(1000)))[0]\n    )[0];\n}\n\nfunction generateListOfRandomNumbers(length) {\n  return new Array(length).fill(null).map(getExpensiveRandomNumber);\n}\n```\n\nThis is the hierarchy of the components:\n\n![Component Hierarchy](/blog/assets/blog/reducing-re-renders/component-hierarchy.png)\n\nSo how does this app perform?\nTo answer this question, I'm going to use the React DevTools Profiler to measure how long it takes to render all the components:\n\n- I just want the `RandomNumberListAndCounter` to re-render, so I can do this by clicking on the\n  increment counter button.\n- Before clicking the counter button, I hit record on the profiler, then after I see the counter increment, I stop recording.\n- If any renders took place, the profile will spit out a flame graph of how long each component took to render.\n\n![First click](/blog/assets/blog/reducing-re-renders/app-first-click.png)\n\n![First click profiler](/blog/assets/blog/reducing-re-renders/app-first-click-profiler.png)\n\nA few observations about the profiler:\n\n1. We can see the total time it took to render `RandomNumberListAndCounter` and all its children was a whopping **1.25 seconds**!\n2. `App` did not re-render (we can tell because of its gray color).\n3. Even though only the text \"Clicked 1 times\" (which belongs to `FancyHeader`) is what changed, all the child components of `RandomNumberListAndCounter` _re-rendered_.\n\n## Optimizing the Example\n\nWe desperately need to fix the slow re-rendering of the example every time we increment the counter. And we can actually do this without memoization, by using `useState`'s **initialization function**.\n\nCurrently, every time we render the component, we're generating and throwing away the random number list.\nBy passing an initialization function to `useState`, React will only invoke the function once (on the component's first render).\n\nThis is the existing problem code:\n\n```javascript\n// In RandomNumberListAndCounter:\nconst [randomNumbers, setRandomNumbers] = useState(\n  generateListOfRandomNumbers(length)\n);\n\n// In RandomStyledNumber:\nconst [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);\n```\n\nAnd this is the fixed code:\n\n```javascript\n// In RandomNumberListAndCounter:\nconst [randomNumbers, setRandomNumbers] = useState(() =\u003e\n  generateListOfRandomNumbers(length)\n);\n\n// In RandomStyledNumber:\nconst [isEven] = useState(() =\u003e getExpensiveRandomNumber() % 2 === 0);\n```\n\n\u003e Note that when we first load the App, its initial render will still be painfully slow. But at least we can tackle slow re-renders easily.\n\nLet's see how this improves the profiler result:\n\n![Initialize state only once](/blog/assets/blog/reducing-re-renders/profiler-init-state.png)\n\n0.9ms - A dramatic improvement!\n\n\u003e At this point, you'd normally stop optimizing your app (unless you expect it to grow in complexity). A 0.9ms re-render time is plenty fast. However, for the sake of learning, we're going to optimize the rest of the app.\n\nBut notice how all the `RandomlyStyledNumber`, `ButtonWithFooter` and `FancyNumberListFormatter` components continue to re-render. These renders are unnecessary given the only thing that changes is the unrelated counter text.\n\nThis where `React.memo` comes in. If we pass a component into `React.memo`, it will only re-render it if its props have changed between re-renders of its parent. Parent components can re-render all they like, but as long as the props passed to the memoized component remain the same, the cached React Elements will be what's returned.\n\nThis is how we call `React.memo`:\n\n```javascript\nconst MyComponentMemoized = React.memo(MyComponent);\n\n// and use it like a regular component in JSX:\n\u003cMyComponentMemoized /\u003e;\n```\n\nSo should we wrap all our components in the example with `React.memo`?\n\nNo. It's neither necessary nor optimal.\n\nLet's take another look at the component hierarchy diagram:\n\n![Component Hierarchy](/blog/assets/blog/reducing-re-renders/component-hierarchy.png)\n\nFrom both the code and the component hierarchy, we can see that memoizing the following components would be redundant:\n\n- `App`: This is the root component. It's pointless memoizing this as it has no parent component to trigger any re-renders.\n- `RandomNumberListAndCounter`: In the context of our example, this component will only re-render when its state, `counter`, changes. Its parent component, `App`, doesn't also have any state so it would never re-render. Therefore wrapping it with `React.memo` is redundant, as memoized components will continue to re-render when its internal state or context changes (which is what we want).\n- `RandomlyStyledNumber`: This component will **only** re-render when its _parent_, `FancyNumberListFormatter`, re-renders. Therefore, only memoizing its parent is sufficient.\n- `FancyHeader`: This component depends on `counter`, as it's passed as a prop. We know that the only thing in our app that triggers a re-render is the `counter` being incremented. Therefore, wrapping this in `React.memo` is redundant - because calling a memoized `FancyHeader` with an incremented `counter` prop will trigger a re-render since the props have changed.\n\nSo only these 2 components would benefit from `memo`:\n\n1. `FancyNumberListFormatter`\n2. `ButtonWithFooter`\n\nBoth of the above components only depend on the `length` prop, and do not care about `counter`. When `counter` changes, these components end up re-rendering, so they're good candidates for memoization.\n\nLet's go ahead and do just that:\n\n```javascript\n/** First change - wrap our existing components with memo: **/\nconst FancyNumberListFormatterMemoized = React.memo(FancyNumberListFormatter);\nconst ButtonWithFooterMemoized = React.memo(ButtonWithFooter);\n\nfunction RandomNumberListAndCounter({ length }: { length: number }) {\n  const [counter, setCounter] = useState(0);\n  const [randomNumbers, setRandomNumbers] = useState(() =\u003e\n    generateListOfRandomNumbers(length)\n  );\n\n  useEffect(() =\u003e {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  const incrementOnClick = () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  };\n\n  const configProp = {\n    name: \"Special counter incrementer\",\n    listLength: length,\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cFancyHeader counter={counter} /\u003e\n      {/** Then we use the memoized components: **/}\n      \u003cFancyNumberListFormatterMemoized numberList={randomNumbers} /\u003e\n      \u003cButtonWithFooterMemoized\n        config={configProp}\n        onClick={incrementOnClick}\n      /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nBefore we check the profiler, I'm going to throttle my CPU speed by 6x in Chrome - so that it simulates users who don't have a developer grade laptop:\n\n![How to throttle CPU](/blog/assets/blog/reducing-re-renders/throttle-cpu.png)\n\nAnd now let's take a look at the React profiler, where I measure what happens after I click the counter button:\n\n![Flamegraph of memoized components](/blog/assets/blog/reducing-re-renders/memo-flamegraph.png)\n\nLooking good - all components that don't need to re-render aren't rendering according to this flamegraph (indicated by the grayed out bars).\n\nBut the flamegraph isn't showing all the re-rendering components, so let's switch views to \"Ranking\":\n\n![Ranking of memoized components](/blog/assets/blog/reducing-re-renders/memo-ranked.png)\n\nOnly two components _should_ re-render: `RandomNumberListFormatter` and `FancyHeader`. `RandomNumberListFormatter` contains the state `counter`, which changes, and `FancyHeader` takes in the prop `counter`.\n\nBut it also looks like `ButtonWithFooter` is re-rendering, even though its props doesn't include the `counter` value.\n\nSo why would `ButtonWithFooter` re-render despite being memoized and having no props change?\n\nAllow me to yank out the cause of this:\n\n```javascript\n// New object assignment\nconst incrementOnClick = () =\u003e {\n  setCounter((prev) =\u003e prev + 1);\n};\n\n// New object assignment\nconst configProp = {\n  name: \"Special counter incrementer\",\n  listLength: length,\n};\n\n// Even though semantically the same, config and incrementOnClick\n// are different objects on each render\n\u003cButtonWithFooterMemoized config={configProp} onClick={incrementOnClick} /\u003e;\n```\n\nThe thing to note is that when `React.memo` compares the previous props with the new props, it uses [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) to compare\nif they've changed. This is a shallow comparison - so two objects that have the same values but different memory references,\nare not equal (remember `{} === {}` evaluates to `false`).\n\nAnd in our example, we're creating **new objects** for `incrementOnClick` and `configProp` on _every render_.\n\nWe can easily fix this by using `useMemo`, to cache the object references:\n\n```jsx\nconst incrementOnClick = useMemo(\n  () =\u003e () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  },\n  []\n);\n\n/**\n * We only create a new object when the `length` changes.\n */\nconst configProp = useMemo(\n  () =\u003e ({\n    name: \"Special counter incrementer\",\n    listLength: length,\n  }),\n  [length]\n);\n```\n\nAnd the new Ranked profiler result is:\n\n![Profiler after useMemo](/blog/assets/blog/reducing-re-renders/profiler-usememo.png)\n\nNow only the two expected components re-render.\n\nBut... notice the awkward syntax for the cached `incrementOnClick`. We want to cache the function itself, not what it returns.\n`useMemo` accepts a function, and caches _the result_ of that function. So to get around that, we pass in a function, that `returns`\nthe function whose reference we want cached.\n\nInstead, we can use `useCallback` instead of `useMemo` - its explicit purpose is to cache callback (i.e. function) references:\n\n```jsx\nconst incrementOnClick = useCallback(() =\u003e {\n  setCounter((prev) =\u003e prev + 1);\n}, []);\n```\n\nNow that we understand how to use memoization in React, in the [next article](https://jithyan.github.io/blog/posts/avoiding-memoization), I'm going to cover how we can _avoid_ memoization!\n"},"estimatedReadingTime":{"minutes":16,"words":1958,"text":"16 min read"},"headings":["A Random Number List Generator and Counter Example","Optimizing the Example"]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"understanding-memoization"},"buildId":"ao1_npWihaqzXY7d22P90","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>