<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A blog on web development with React and Typescript."/><title>Optimizing React: Part 1 - Understanding Renders</title><meta name="next-head-count" content="16"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/blog/_next/static/css/f2e8ce7a08454583.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/f2e8ce7a08454583.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/a7fa4402bacb9a02.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/a7fa4402bacb9a02.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-b4bc6d1b20a0a573.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ed62687b5581921b.js" defer=""></script><script src="/blog/_next/static/chunks/main-cb7b41c9cdc2a097.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f51201e12e7e4d94.js" defer=""></script><script src="/blog/_next/static/chunks/299-6b06e3596b88e631.js" defer=""></script><script src="/blog/_next/static/chunks/503-5f0d2c6f9d0a5f52.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-80fde88d01873cd0.js" defer=""></script><script src="/blog/_next/static/ao1_npWihaqzXY7d22P90/_buildManifest.js" defer=""></script><script src="/blog/_next/static/ao1_npWihaqzXY7d22P90/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Inter">@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZs.woff) format('woff')}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZJhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZthjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZNhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZxhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZBhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZFhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="bg-gray-900"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-lg md:text-xl font-bold underline text-teal-500 mb-20 pt-8"><a class="hover:text-sky-400" href="/blog">Home</a></h2><article id="blog-post" class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-pink-500 font-bold text-center text-6xl tracking-tighter leading-tight mx-auto md:text-left">Optimizing React: Part 1 - Understanding Renders</h1><div class="mt-2 mb-6 text-lg text-white font-semibold"><div class="mb-1"><time dateTime="2022-09-08T20:00:00.000Z">September	9, 2022</time> |<!-- --> <span>Jithya Nanayakkara</span> |<!-- --> <span>12 min read</span></div><div><a class="text-base text-teal-500 underline hover:text-sky-400" href="#inject-comments-for-uterances">Jump to comments</a></div></div></div><section class="mx-auto max-w-md text-sm text-left text-gray-500 dark:text-gray-400 mb-2 rounded-lg"><h2 class="text-center font-semibold text-basis text-gray-700 uppercase bg-gray-50 dark:bg-gray-700 dark:text-gray-400 py-1.5 px-2.5">Table of Contents</h2><div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#an-overview-of-react" class="underline text-gray-900 whitespace-nowrap dark:text-white">1<!-- -->. <!-- -->An overview of React</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#understanding-what-happens-in-a-render" class="underline text-gray-900 whitespace-nowrap dark:text-white">2<!-- -->. <!-- -->Understanding what happens in a render</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#what-about-effects" class="underline text-gray-900 whitespace-nowrap dark:text-white">3<!-- -->. <!-- -->What about effects?</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#to-be-continued" class="underline text-gray-900 whitespace-nowrap dark:text-white">4<!-- -->. <!-- -->To be continued...</a></div></div></section><div class="max-w-2xl mx-auto text-gray-300"><div class="markdown-styles_markdown__8Ahqd"><hr/>
<p>This is the first article in a series covering techniques for optimizing React&#x27;s performance by minimizing renders.</p>
<ol>
<li>Part 1 - Understanding Renders (this post)</li>
<li><a href="https://jithyan.github.io/blog/posts/understanding-memoization">Part 2 - Understanding Memoization</a></li>
<li><a href="https://jithyan.github.io/blog/posts/avoiding-memoization">Part 3 - Avoiding Memoization</a></li>
</ol>
<hr/>
<p>In my experience, React&#x27;s memoization functions have been a source of confusion for many developers - either being criminally overused in the name of &quot;performance&quot;, or woefully underutilized.</p>
<p>In this series, I&#x27;m going to attempt to dispel the uncertainty of when to use these functions, understand their trade-offs, and introduce you to ways of avoiding them altogether.</p>
<p>So what is <a href="https://en.wikipedia.org/wiki/Memoization">Memoization</a>? It&#x27;s a technique where the result of an expensive computation is cached to improve performance on subsequent calls to it. It&#x27;s a trade-off that consumes more memory to save on execution time.</p>
<p>In React, its memoization functions are primarily used to:</p>
<ol>
<li>Avoid unnecessary re-renders of a component (using <code class="bg-slate-800 px-2">React.memo</code>) or re-execution of expensive logic (using <code class="bg-slate-800 px-2">useMemo</code> or state initializers).</li>
<li>Provide a stable reference for objects (both <code class="bg-slate-800 px-2">useMemo</code> and <code class="bg-slate-800 px-2">useCallback</code>).</li>
</ol>
<p>Devs tend to focus on the first point - where some <a href="https://royi-codes.vercel.app/thousand-usecallbacks/">overuse those functions</a> in the name of &quot;performance&quot;. But point number 2 is an important use case for React&#x27;s functional components, especially when writing libraries, and is often overlooked.</p>
<p>To really understand in which circumstances we make use of them, I need to cover the basics of how React works - apologies to those who are already familiar with this, but it&#x27;s useful that everyone is on the same page with the terminology used here.</p>
<h2 level="2" node="[object Object]" id="an-overview-of-react">An overview of React</h2>
<blockquote>
<p>For simplicity, I&#x27;m going to pretend React classes don&#x27;t exist.</p>
</blockquote>
<p>React provides us with a component based <a href="https://computersciencewiki.org/index.php/Abstraction">abstraction</a> for easily updating the DOM in response to state changes. This is done by representing the DOM with a <strong>Virtual DOM</strong> (V-DOM), that is nothing more than a lightweight representation of the actual DOM.</p>
<p>In other words, the V-DOM is just a collection of simple Javascript objects used to represent the actual DOM.</p>
<p>The idea behind this is that since updates to the actual DOM are expensive operations, we could instead make frequent updates to the V-DOM, and then figure out which of the actual DOM elements need to be updated.</p>
<p>This process of finding the difference between the previous and next V-DOM state is called <a href="https://reactjs.org/docs/reconciliation.html">reconciliation</a>. Reconciliation is fast but does not aim to be very accurate - just good enough to minimize unnecessary updates to the actual DOM for most practical use cases.</p>
<p>With that out of the way, time for some terminology:</p>
<ul>
<li>A React <strong>Element</strong> is a simple Javascript object that represents a node in the V-DOM.</li>
<li>A React <strong>Component</strong> is a function that accepts some <em>props</em> and returns React Elements.</li>
</ul>
<p>This is what a React <strong>element</strong> looks like, and you can get this by just console logging the output of a component:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/react-elements-object.png" alt="Initial"/></p>
<ul>
<li>A <strong>render</strong> is when the React Component (i.e. the function) is executed.</li>
<li>A <strong>commit</strong> is when React actually updates a DOM element.</li>
</ul>
<p>Note the difference between <code class="bg-slate-800 px-2">render</code> and <code class="bg-slate-800 px-2">commit</code>. Many developers confuse the two, but they are <em>not</em> the same. When a component &quot;renders&quot;, it does not necessarily mean the DOM is going to be updated - React may have figured out that nothing has changed after a state update, and skip updating portions of the DOM.</p>
<p>To really drive home this point, <strong>React components can render many, many times</strong>. These are just basic functions being executed after all - and in most cases, they execute fast with minimal impact on performance. It&#x27;s objects like the one pictured above that get updated every render - based on how they change, React will decide which DOM elements to update.</p>
<h2 level="2" node="[object Object]" id="understanding-what-happens-in-a-render">Understanding what happens in a render</h2>
<p>Here are some possible reasons a component would re-render (this list is not exhaustive):</p>
<ol>
<li>The component&#x27;s <strong>parent</strong> has re-rendered.</li>
<li>The component&#x27;s <strong>state</strong> changed (i.e. <code class="bg-slate-800 px-2">setState</code> was called).</li>
<li>The component is a subscriber to a React Context - every time the Context value changes, the component will re-render.</li>
</ol>
<p>Understanding why your component has re-rendered is a critical first step in diagnosing React performance problems.
As an exercise, see if you could identify what would cause the example component below to re-render:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function Counter() {
  const [counter, setCounter] = useState(0);
  const user = useContext(UserContext);

  // A callback to increment the counter, passed to FancyButton
  const incrementer = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  };

  // An object that is the prop to FancyButton
  // I&#x27;m aware this is a little unusual, but there are situations where
  // you pass in complex objects as props to a component.
  const buttonConfig = {
    name: &quot;hello&quot;,
    display: counter,
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;My Special Counter&lt;/h3&gt;
      &lt;p&gt;Hello, {user}!&lt;/p&gt;
      &lt;FancyButton config={buttonConfig} onClick={incrementer} /&gt;
    &lt;/div&gt;
  );
}</code></div></pre>
<p>The following are triggers that would cause <code class="bg-slate-800 px-2">Counter</code> to re-render:</p>
<ol>
<li>The <em>parent</em> of <code class="bg-slate-800 px-2">Counter</code> is re-rendered.</li>
<li><code class="bg-slate-800 px-2">setCounter</code> is called via the <code class="bg-slate-800 px-2">incrementer</code> callback (and it&#x27;s called with a <em>different</em> value - React has an optimization where if the new value to <code class="bg-slate-800 px-2">setState</code> is the same as the old, a re-render will not happen).</li>
<li>The object returned by <code class="bg-slate-800 px-2">useContext</code> has changed.</li>
</ol>
<p>Every time one of the above triggers are set off, React will execute the <code class="bg-slate-800 px-2">Counter</code> function again, and return the child elements.
These child elements, written as JSX, are nothing more than functions too - they are compiled into <code class="bg-slate-800 px-2">React.createElement(args)</code> function calls.
The reason why we use JSX is that it provides a nice familiar <a href="https://en.wikipedia.org/wiki/Declarative_programming">declarative</a> abstraction like HTML to write our components - just imagine writing a page as a bunch of nested function calls!</p>
<p>Below is an example of what React code <a href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html">(before v17.0)</a> would transform to (taken from the <a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx">Babel React Transform Plugin docs</a>):</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const profile = React.createElement(
  &quot;div&quot;,
  null,
  React.createElement(&quot;img&quot;, { src: &quot;avatar.png&quot;, className: &quot;profile&quot; }),
  React.createElement(&quot;h3&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;))
);</code></div></pre>
<p>So continuing with our example, with each re-render of <code class="bg-slate-800 px-2">Counter</code>, the following will happen:</p>
<ol>
<li><code class="bg-slate-800 px-2">incrementer</code> will be assigned to a <em>new</em> callback <strong>object</strong>. Remember functions in Javascript are objects too!</li>
<li><code class="bg-slate-800 px-2">buttonConfig</code> will also be assigned to a new object. Remember that <code class="bg-slate-800 px-2">{} !== {}</code>. So both <code class="bg-slate-800 px-2">incrementer</code> and <code class="bg-slate-800 px-2">buttonConfig</code> will be assigned to <strong>new references</strong> in memory on <em>every render</em>.</li>
<li>All the React Elements returned from <code class="bg-slate-800 px-2">Counter</code> will be <em>recreated</em>.</li>
</ol>
<p>Now let&#x27;s discuss performance. Given what we know from above, would repeated renders of <code class="bg-slate-800 px-2">Counter</code> impact performance by constantly re-allocating memory for variables and running all those functions again? Not really.</p>
<p>These operations are quite cheap, and the Javascript runtime is optimized for doing these operations efficiently. But this could be a problem if you have an app with hundreds or thousands of components re-rendering frequently (and of course, it depends on the user&#x27;s hardware).</p>
<p>So do we wrap everything we can with <code class="bg-slate-800 px-2">memo</code>, <code class="bg-slate-800 px-2">useMemo</code> and <code class="bg-slate-800 px-2">useCallback</code>? Some people do, which is probably why you see a lot of blog posts saying to avoid abusing React&#x27;s memo functions for optimizing performance - it&#x27;s because the act of memoization trades off time for space. We cache prior values and return them instead of executing functions again.</p>
<p>But there&#x27;s a small cost with this. And the cost could be significant if we end up not using the cached values much, and end up frequently caching a value, throwing it away because it&#x27;s stale, and then creating a new one.</p>
<p><strong>Since it&#x27;s easy to shoot yourself in the foot and use these incorrectly, premature optimization should be avoided.</strong></p>
<p>However as long as you understand how React works, choosing when to use the memoization functions is pretty straightforward. And in my experience, you don&#x27;t need to use them too often.</p>
<h2 level="2" node="[object Object]" id="what-about-effects">What about effects?</h2>
<p>If you now understand what goes on when React renders a component, you may wonder when does <code class="bg-slate-800 px-2">useEffect</code> and <code class="bg-slate-800 px-2">useLayoutEffect</code> run. Understanding these hooks is beyond the scope of this series, so a short summary of them is:</p>
<ol>
<li><code class="bg-slate-800 px-2">useLayoutEffects</code> runs <em>after</em> a <strong>render</strong> but <em>before</em> the browser paints the DOM (i.e. when you can actually see your changes). It is a <em>synchronous</em> (i.e. blocking) operation.</li>
<li><code class="bg-slate-800 px-2">useEffects</code> runs <em>after</em> the component <strong>renders</strong> <em>and</em> the browser paints the DOM. It is an <em>asynchronous</em> (non-blocking) operation.</li>
</ol>
<p><a href="https://kentcdodds.com/blog/useeffect-vs-uselayouteffect">This article by Kent C Dodds</a>, explains when you should prefer one over the other.</p>
<p>And this image by <a href="https://github.com/donavon/hook-flow">Donavan West</a> visualizes when these hooks run:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/hook-flow.png" alt="When effect hooks run"/></p>
<h2 level="2" node="[object Object]" id="to-be-continued">To be continued...</h2>
<p>Now that we&#x27;ve covered why a component can re-render, and how variables are given new references on each render, we can dive into optimization - which we will do in my <a href="https://jithyan.github.io/blog/posts/understanding-memoization">next article</a>.</p></div></div><section><div id="inject-comments-for-uterances"></div></section></article></div></main></div><footer class="bg-slate-800"><div style="display:table" class="mx-auto"><ul class="list-none flex flex-row text-lg text-teal-500 underline font-semibold p-2"><li class="mr-4 max-w-md"><a href="https://github.com/jithyan" class="hover:text-sky-400 " target="_blank">Github</a></li><li class="mr-4 max-w-md"><a href="https://www.linkedin.com/in/jithyan/" class=" hover:text-sky-400 " target="_blank">LinkedIn</a></li><li class=""><a href="https://jithyan.github.io/resume/" class=" hover:text-sky-400" target="_blank">Resume</a></li></ul></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Optimizing React: Part 1 - Understanding Renders","date":"2022-09-08T20:00:00.000Z","slug":"understanding-renders","author":{"name":"Jithya Nanayakkara"},"content":"\n---\n\nThis is the first article in a series covering techniques for optimizing React's performance by minimizing renders.\n\n1. Part 1 - Understanding Renders (this post)\n2. [Part 2 - Understanding Memoization](https://jithyan.github.io/blog/posts/understanding-memoization)\n3. [Part 3 - Avoiding Memoization](https://jithyan.github.io/blog/posts/avoiding-memoization)\n\n---\n\nIn my experience, React's memoization functions have been a source of confusion for many developers - either being criminally overused in the name of \"performance\", or woefully underutilized.\n\nIn this series, I'm going to attempt to dispel the uncertainty of when to use these functions, understand their trade-offs, and introduce you to ways of avoiding them altogether.\n\nSo what is [Memoization](https://en.wikipedia.org/wiki/Memoization)? It's a technique where the result of an expensive computation is cached to improve performance on subsequent calls to it. It's a trade-off that consumes more memory to save on execution time.\n\nIn React, its memoization functions are primarily used to:\n\n1. Avoid unnecessary re-renders of a component (using `React.memo`) or re-execution of expensive logic (using `useMemo` or state initializers).\n2. Provide a stable reference for objects (both `useMemo` and `useCallback`).\n\nDevs tend to focus on the first point - where some [overuse those functions](https://royi-codes.vercel.app/thousand-usecallbacks/) in the name of \"performance\". But point number 2 is an important use case for React's functional components, especially when writing libraries, and is often overlooked.\n\nTo really understand in which circumstances we make use of them, I need to cover the basics of how React works - apologies to those who are already familiar with this, but it's useful that everyone is on the same page with the terminology used here.\n\n## An overview of React\n\n\u003e For simplicity, I'm going to pretend React classes don't exist.\n\nReact provides us with a component based [abstraction](https://computersciencewiki.org/index.php/Abstraction) for easily updating the DOM in response to state changes. This is done by representing the DOM with a **Virtual DOM** (V-DOM), that is nothing more than a lightweight representation of the actual DOM.\n\nIn other words, the V-DOM is just a collection of simple Javascript objects used to represent the actual DOM.\n\nThe idea behind this is that since updates to the actual DOM are expensive operations, we could instead make frequent updates to the V-DOM, and then figure out which of the actual DOM elements need to be updated.\n\nThis process of finding the difference between the previous and next V-DOM state is called [reconciliation](https://reactjs.org/docs/reconciliation.html). Reconciliation is fast but does not aim to be very accurate - just good enough to minimize unnecessary updates to the actual DOM for most practical use cases.\n\nWith that out of the way, time for some terminology:\n\n- A React **Element** is a simple Javascript object that represents a node in the V-DOM.\n- A React **Component** is a function that accepts some _props_ and returns React Elements.\n\nThis is what a React **element** looks like, and you can get this by just console logging the output of a component:\n\n![Initial](/blog/assets/blog/reducing-re-renders/react-elements-object.png)\n\n- A **render** is when the React Component (i.e. the function) is executed.\n- A **commit** is when React actually updates a DOM element.\n\nNote the difference between `render` and `commit`. Many developers confuse the two, but they are _not_ the same. When a component \"renders\", it does not necessarily mean the DOM is going to be updated - React may have figured out that nothing has changed after a state update, and skip updating portions of the DOM.\n\nTo really drive home this point, **React components can render many, many times**. These are just basic functions being executed after all - and in most cases, they execute fast with minimal impact on performance. It's objects like the one pictured above that get updated every render - based on how they change, React will decide which DOM elements to update.\n\n## Understanding what happens in a render\n\nHere are some possible reasons a component would re-render (this list is not exhaustive):\n\n1. The component's **parent** has re-rendered.\n2. The component's **state** changed (i.e. `setState` was called).\n3. The component is a subscriber to a React Context - every time the Context value changes, the component will re-render.\n\nUnderstanding why your component has re-rendered is a critical first step in diagnosing React performance problems.\nAs an exercise, see if you could identify what would cause the example component below to re-render:\n\n```jsx\nfunction Counter() {\n  const [counter, setCounter] = useState(0);\n  const user = useContext(UserContext);\n\n  // A callback to increment the counter, passed to FancyButton\n  const incrementer = () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  };\n\n  // An object that is the prop to FancyButton\n  // I'm aware this is a little unusual, but there are situations where\n  // you pass in complex objects as props to a component.\n  const buttonConfig = {\n    name: \"hello\",\n    display: counter,\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003ch3\u003eMy Special Counter\u003c/h3\u003e\n      \u003cp\u003eHello, {user}!\u003c/p\u003e\n      \u003cFancyButton config={buttonConfig} onClick={incrementer} /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nThe following are triggers that would cause `Counter` to re-render:\n\n1. The _parent_ of `Counter` is re-rendered.\n2. `setCounter` is called via the `incrementer` callback (and it's called with a _different_ value - React has an optimization where if the new value to `setState` is the same as the old, a re-render will not happen).\n3. The object returned by `useContext` has changed.\n\nEvery time one of the above triggers are set off, React will execute the `Counter` function again, and return the child elements.\nThese child elements, written as JSX, are nothing more than functions too - they are compiled into `React.createElement(args)` function calls.\nThe reason why we use JSX is that it provides a nice familiar [declarative](https://en.wikipedia.org/wiki/Declarative_programming) abstraction like HTML to write our components - just imagine writing a page as a bunch of nested function calls!\n\nBelow is an example of what React code [(before v17.0)](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) would transform to (taken from the [Babel React Transform Plugin docs](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx)):\n\n```javascript\nconst profile = React.createElement(\n  \"div\",\n  null,\n  React.createElement(\"img\", { src: \"avatar.png\", className: \"profile\" }),\n  React.createElement(\"h3\", null, [user.firstName, user.lastName].join(\" \"))\n);\n```\n\nSo continuing with our example, with each re-render of `Counter`, the following will happen:\n\n1. `incrementer` will be assigned to a _new_ callback **object**. Remember functions in Javascript are objects too!\n2. `buttonConfig` will also be assigned to a new object. Remember that `{} !== {}`. So both `incrementer` and `buttonConfig` will be assigned to **new references** in memory on _every render_.\n3. All the React Elements returned from `Counter` will be _recreated_.\n\nNow let's discuss performance. Given what we know from above, would repeated renders of `Counter` impact performance by constantly re-allocating memory for variables and running all those functions again? Not really.\n\nThese operations are quite cheap, and the Javascript runtime is optimized for doing these operations efficiently. But this could be a problem if you have an app with hundreds or thousands of components re-rendering frequently (and of course, it depends on the user's hardware).\n\nSo do we wrap everything we can with `memo`, `useMemo` and `useCallback`? Some people do, which is probably why you see a lot of blog posts saying to avoid abusing React's memo functions for optimizing performance - it's because the act of memoization trades off time for space. We cache prior values and return them instead of executing functions again.\n\nBut there's a small cost with this. And the cost could be significant if we end up not using the cached values much, and end up frequently caching a value, throwing it away because it's stale, and then creating a new one.\n\n**Since it's easy to shoot yourself in the foot and use these incorrectly, premature optimization should be avoided.**\n\nHowever as long as you understand how React works, choosing when to use the memoization functions is pretty straightforward. And in my experience, you don't need to use them too often.\n\n## What about effects?\n\nIf you now understand what goes on when React renders a component, you may wonder when does `useEffect` and `useLayoutEffect` run. Understanding these hooks is beyond the scope of this series, so a short summary of them is:\n\n1. `useLayoutEffects` runs _after_ a **render** but _before_ the browser paints the DOM (i.e. when you can actually see your changes). It is a _synchronous_ (i.e. blocking) operation.\n2. `useEffects` runs _after_ the component **renders** _and_ the browser paints the DOM. It is an _asynchronous_ (non-blocking) operation.\n\n[This article by Kent C Dodds](https://kentcdodds.com/blog/useeffect-vs-uselayouteffect), explains when you should prefer one over the other.\n\nAnd this image by [Donavan West](https://github.com/donavon/hook-flow) visualizes when these hooks run:\n\n![When effect hooks run](/blog/assets/blog/reducing-re-renders/hook-flow.png)\n\n## To be continued...\n\nNow that we've covered why a component can re-render, and how variables are given new references on each render, we can dive into optimization - which we will do in my [next article](https://jithyan.github.io/blog/posts/understanding-memoization).\n"},"estimatedReadingTime":{"minutes":12,"words":1551,"text":"12 min read"},"headings":["An overview of React","Understanding what happens in a render","What about effects?","To be continued..."]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"understanding-renders"},"buildId":"ao1_npWihaqzXY7d22P90","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>