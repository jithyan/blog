<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A blog on web development with React and Typescript."/><title>My Current Favourite TypeScript Tips</title><meta name="next-head-count" content="16"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/blog/_next/static/css/08cb2869a2e116ed.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/08cb2869a2e116ed.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/a7fa4402bacb9a02.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/a7fa4402bacb9a02.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-26cc22ab18d447b4.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ed62687b5581921b.js" defer=""></script><script src="/blog/_next/static/chunks/main-cb7b41c9cdc2a097.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f51201e12e7e4d94.js" defer=""></script><script src="/blog/_next/static/chunks/299-6b06e3596b88e631.js" defer=""></script><script src="/blog/_next/static/chunks/503-5f0d2c6f9d0a5f52.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-9b43c7b6d90b640a.js" defer=""></script><script src="/blog/_next/static/ucJQ1YAxIHSH9cRcLd6on/_buildManifest.js" defer=""></script><script src="/blog/_next/static/ucJQ1YAxIHSH9cRcLd6on/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Inter">@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZs.woff) format('woff')}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZJhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZthjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZNhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZxhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZBhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZFhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="bg-gray-900"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-lg md:text-xl font-bold underline text-teal-500 mb-20 pt-8"><a class="hover:text-sky-400" href="/blog">Home</a></h2><article class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-pink-500 font-bold text-center text-6xl tracking-tighter leading-tight mx-auto md:text-left">My Current Favourite TypeScript Tips</h1><div class="mt-2 mb-6 text-lg text-white font-semibold"><time dateTime="2022-10-01T20:00:00.000Z">October	2, 2022</time> | <span>Jithya Nanayakkara</span> <!-- -->| <span>10 min read</span></div></div><div class="max-w-2xl mx-auto text-gray-300"><div class="markdown-styles_markdown__8Ahqd"><p>This is a small collection of features and patterns I&#x27;ve found useful when working with TypeScript projects. Do note, what I&#x27;ve written is somewhat advanced, and wouldn&#x27;t be particularly useful unless you already know your way around TypeScript.</p>
<h2>Creating type safe utility functions</h2>
<p>There are times when certain libraries or APIs don&#x27;t have great type definitions, or unexpected types.
An example of this you may have come across is <code class="bg-slate-800 px-2">Object.keys</code>, which returns <code class="bg-slate-800 px-2">string[]</code> rather than the actual keys (<a href="https://github.com/Microsoft/TypeScript/issues/12870">and this is the intended behaviour by the TypeScript authors</a>).</p>
<p>When you do come across this situation, don&#x27;t shy away from creating utility functions whose sole purpose is to get better types.
I always create a type safe <code class="bg-slate-800 px-2">Object.keys</code> helper, and whenever I use the <a href="https://immutable-js.com/">ImmutableJS</a> library, which has notoriously lousy types, I create separate functions for accessing those objects rather than calling the methods on them directly.</p>
<p>Here&#x27;s the helper I use for <code class="bg-slate-800 px-2">Object.keys</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function getObjectKeys&lt;Object extends Record&lt;string, any&gt;&gt;(
  obj: Object
): Array&lt;keyof Object&gt; {
  return Object.keys(obj);
}</code></div></pre>
<h2>Conditional types</h2>
<p>Conditional types essentially allow you to check if a type <code class="bg-slate-800 px-2">A</code>, is, or is a subset of another type <code class="bg-slate-800 px-2">B</code>.
You use it in the form <code class="bg-slate-800 px-2">A extends B ? &lt;true-expression&gt; : &lt;false-expression&gt;</code>.</p>
<p>One example of where I use this, is when I create a <code class="bg-slate-800 px-2">DeepPartial</code> utility type - the inbuilt <code class="bg-slate-800 px-2">Partial</code> type only
makes the fields at the first level of an object optional, however <code class="bg-slate-800 px-2">DeepPartial</code> makes every field at every level of the object optional:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type DeepPartial&lt;Object extends Record&lt;string, any&gt;&gt; = {
  [Property in keyof Object]?:
    Object[Property] extends Record&lt;string, any&gt;
      ? DeepPartial&lt;Object[Property]&gt;
      : Object[Property];
};

interface Person {
    name: {
      first: string
      last: string;
    }
    age: number
}
type PartialPerson = DeepPartial&lt;Person&gt;;

// Results in:
{
  name?: {
    first?: string
    last?: string;
  }
  age?: number
}</code></div></pre>
<ol>
<li>DeepPartial takes in 1 Generic parameter, <code class="bg-slate-800 px-2">Object</code>, and we constrain it to be a plain JS object</li>
<li>We extract the keys in <code class="bg-slate-800 px-2">Object</code> using: <code class="bg-slate-800 px-2">keyof Object</code></li>
<li>We then iterate over every key using the operator <code class="bg-slate-800 px-2">in</code>, and assign the key to the variable <code class="bg-slate-800 px-2">Property</code></li>
<li>We add a new field to the resulting object with an optional field: <code class="bg-slate-800 px-2">[Property]?</code></li>
<li>We check if the value at <code class="bg-slate-800 px-2">Object[Property]</code> is another object using: <code class="bg-slate-800 px-2">Object[Property] extends Record&lt;string, any&gt; ?</code></li>
<li>If it is an object, we recursively call <code class="bg-slate-800 px-2">DeepPartial</code> on it</li>
<li>Else, we just return the value at <code class="bg-slate-800 px-2">Object[Property]</code></li>
</ol>
<h3>Validation messages</h3>
<p>We can even use conditional types to provide custom validation messages to arguments of a function!</p>
<blockquote>
<p>I don&#x27;t recommend you add this complexity to your application code, but this would be useful if you maintain a library.</p>
</blockquote>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type Validate&lt;
  Arg,
  ExpectedType,
  ErrorMsg extends string
&gt; = Arg extends ExpectedType ? Arg : ErrorMsg;

function sendMessage&lt;Arg&gt;(
  message: Validate&lt;Arg, string, &quot;The message must be of type &#x27;string&#x27;&quot;&gt;
) {}

// This won&#x27;t compile!
// Validate will return the specific type literal:
//  &quot;The message must be of type &#x27;string&#x27;&quot;
sendMessage(1);

// compiles without issues:
sendMessage(&quot;hello&quot;);</code></div></pre>
<h2>Renaming Fields of an Object</h2>
<p>Let&#x27;s say you need to add getter functions to an object, based on the existing fields in it.
You can use the <code class="bg-slate-800 px-2">as</code> keyword when iterating over fields using <code class="bg-slate-800 px-2">in</code>, to rename the existing fields:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type Getters&lt;Object extends Record&lt;string, any&gt;&gt; = {
  [Property in keyof Object as `get${Capitalize&lt;
    string &amp; Property
  &gt;}`]: () =&gt; Object[Property];
};

const person = {
  name: &quot;John&quot;,
  age: 18,
};
type PersonAsGetters = Getters&lt;typeof person&gt;;

// results in:
{
  getName: () =&gt; string;
  getAge: () =&gt; number;
}</code></div></pre>
<p>Note: <code class="bg-slate-800 px-2">Capitalize</code> is another inbuilt TypeScript utility.</p>
<h2>Using <code class="bg-slate-800 px-2">infer</code></h2>
<p>You use <code class="bg-slate-800 px-2">infer</code> with conditional types in order to extract types to another generic variable.
Seeing this in action would help you understand what the above means better.</p>
<blockquote>
<p>Remember, we can only use <code class="bg-slate-800 px-2">infer</code> in the <code class="bg-slate-800 px-2">extends</code> clause of a conditional type.</p>
</blockquote>
<p>Here&#x27;s an example where I convert a string from <code class="bg-slate-800 px-2">kebab-case</code> to <code class="bg-slate-800 px-2">snake_case</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type KebabToSnakeCase&lt;S extends string&gt; = S extends `${infer Char}${infer Rest}`
  ? Char extends &quot;-&quot;
    ? `_${KebabToSnakeCase&lt;Rest&gt;}`
    : `${Char}${KebabToSnakeCase&lt;Rest&gt;}`
  : S;

type Result = KebabToSnakeCase&lt;&quot;convert-this-kebab-case-to-snake-case&quot;&gt;;

// results in:
// &quot;convert_this_kebab_case_to_snake_case&quot;;</code></div></pre>
<p>What the following line:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">S extends `${infer Char}${infer Rest}`</code></div></pre>
<p>does is that it checks if the generic <code class="bg-slate-800 px-2">S</code> is a string that is of the template <code class="bg-slate-800 px-2">${Char}${Rest}</code> - <code class="bg-slate-800 px-2">Char</code> and <code class="bg-slate-800 px-2">Rest</code> are named
generic variables, and TypeScript will figure out what they are. If the string <em>does conform</em> to it, <code class="bg-slate-800 px-2">Char</code> will be the
first character of a string, while <code class="bg-slate-800 px-2">Rest</code> will be the remaining characters in the string.</p>
<p>Here&#x27;s another example where I extract the value from an object, given the dot-separated path - just like in Lodash&#x27;s <code class="bg-slate-800 px-2">get</code> utility:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type ExtractTypeFromPath&lt;
  Path extends string,
  Object extends Record&lt;string, any&gt;
&gt; = Path extends `${infer Property}.${infer RestOfPath}`
  ? ExtractTypeFromPath&lt;RestOfPath, Object[Property]&gt;
  : Object[Path];

interface Person {
  data: {
    firstName: string;
    lastName: string;
    sensitive: {
      age: number;
    };
  };
}
// Results in number
type TypeOfAge = ExtractTypeFromPath&lt;&quot;data.sensitive.age&quot;, Person&gt;;</code></div></pre>
<h2>Dynamically inferring types from JavaScript</h2>
<p>In the examples so far, we&#x27;ve been dealing exclusively with types - which have no
impact on the actual execution of our app - after all, the compiler just strips out
all the type definitions.</p>
<p>However, one of the most useful patterns I&#x27;ve found is to derive types from
actual JavaScript objects. The trick is to use <code class="bg-slate-800 px-2">Readonly</code> or <code class="bg-slate-800 px-2">as const</code> to
ensure that the most accurate types would be derived.</p>
<p>For example, if you were to do this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;];</code></div></pre>
<p><code class="bg-slate-800 px-2">typeof fieldNames</code> would give you <code class="bg-slate-800 px-2">string[]</code></p>
<p>However, if we did this instead:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;] as const;</code></div></pre>
<p>This would give you <code class="bg-slate-800 px-2">(&quot;name&quot; | &quot;age&quot;)[]</code> - far more useful. We can then extract the values in the array using:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;] as const;
type FieldName = typeof fieldNames[number];

// results in: FieldName = &quot;name&quot; | &quot;age&quot;</code></div></pre>
<p>Below is an example of a situation where I used this approach. I needed to make a GET request
to a REST API, and I could specify what fields in the data I want returned in the response. I simply
had to pass the field names as query parameters in the URL.</p>
<p>Rather than putting the field names as query parameters in a hard to read URL, I decided to put the fields I want
in an array, then convert the array to the appropriate query parameters.</p>
<p>However, TypeScript types become an issue - how does it know what the response object type is
when it could change depending on what I put in the Javascript array?</p>
<p>This is how I did it:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const pickFields = [&quot;age&quot;, &quot;name&quot;, &quot;height&quot;, &quot;isMember&quot;] as const;

interface ApiResponse {
  age: number;
  name: {
    firstName: string;
    lastName: string;
  };
  height: string;
  isMember: boolean;
}
// Note that I&#x27;m not specifying pickFields is of type &quot;Array&lt;keyof ApiResponse&gt;&quot;!

async function getPersonDetails&lt;
  RequestedFields extends ReadonlyArray&lt;typeof pickFields[number]&gt;
&gt;(
  ...fieldNames: RequestedFields
): Promise&lt;{
  [Field in RequestedFields extends ReadonlyArray&lt;infer FieldNameValue&gt;
    ? FieldNameValue
    : never]: ApiResponse[Field];
}&gt; {
  return callRestApi(&quot;/v1/person&quot;, fieldNames) as any;
}

// Will give you { age: number; isMember: boolean; height: string}
const response = await getPersonDetails(&quot;age&quot;, &quot;isMember&quot;, &quot;height&quot;);</code></div></pre>
<p>This is the really cool part of making <code class="bg-slate-800 px-2">pickFields</code> a <code class="bg-slate-800 px-2">const</code> - TypeScript
can figure out from the signature of <code class="bg-slate-800 px-2">getPersonDetails</code> that the values in
<code class="bg-slate-800 px-2">pickFields</code> <strong>are a member of</strong> <code class="bg-slate-800 px-2">ApiResponse</code>!</p>
<p>If we put the string &quot;woof&quot; into <code class="bg-slate-800 px-2">pickFields</code>, <code class="bg-slate-800 px-2">getPersonDetails</code> will fail compilation with an error, because &quot;woof&quot; is not a field in <code class="bg-slate-800 px-2">ApiResponse</code>!</p>
<p>And if we put &quot;meow&quot; into the arguments of <code class="bg-slate-800 px-2">getPersonDetails</code>, it will also fail for the same reason.</p></div></div></article></div></main></div><footer class="bg-slate-800"><div style="display:table" class="mx-auto"><ul class="list-none flex flex-row text-lg text-teal-500 underline font-semibold p-2"><li class="mr-4 max-w-md"><a href="https://github.com/jithyan" class="hover:text-sky-400 ">Github</a></li><li class="mr-4 max-w-md"><a href="https://www.linkedin.com/in/jithyan/" class=" hover:text-sky-400 ">LinkedIn</a></li><li class=""><a href="https://jithyan.github.io/resume/" class=" hover:text-sky-400 ">Resume</a></li></ul></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"My Current Favourite TypeScript Tips","date":"2022-10-01T20:00:00.000Z","slug":"favourite-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\r\nThis is a small collection of features and patterns I've found useful when working with TypeScript projects. Do note, what I've written is somewhat advanced, and wouldn't be particularly useful unless you already know your way around TypeScript.\r\n\r\n## Creating type safe utility functions\r\n\r\nThere are times when certain libraries or APIs don't have great type definitions, or unexpected types.\r\nAn example of this you may have come across is `Object.keys`, which returns `string[]` rather than the actual keys ([and this is the intended behaviour by the TypeScript authors](https://github.com/Microsoft/TypeScript/issues/12870)).\r\n\r\nWhen you do come across this situation, don't shy away from creating utility functions whose sole purpose is to get better types.\r\nI always create a type safe `Object.keys` helper, and whenever I use the [ImmutableJS](https://immutable-js.com/) library, which has notoriously lousy types, I create separate functions for accessing those objects rather than calling the methods on them directly.\r\n\r\nHere's the helper I use for `Object.keys`:\r\n\r\n```jsx\r\nfunction getObjectKeys\u003cObject extends Record\u003cstring, any\u003e\u003e(\r\n  obj: Object\r\n): Array\u003ckeyof Object\u003e {\r\n  return Object.keys(obj);\r\n}\r\n```\r\n\r\n## Conditional types\r\n\r\nConditional types essentially allow you to check if a type `A`, is, or is a subset of another type `B`.\r\nYou use it in the form `A extends B ? \u003ctrue-expression\u003e : \u003cfalse-expression\u003e`.\r\n\r\nOne example of where I use this, is when I create a `DeepPartial` utility type - the inbuilt `Partial` type only\r\nmakes the fields at the first level of an object optional, however `DeepPartial` makes every field at every level of the object optional:\r\n\r\n```jsx\r\ntype DeepPartial\u003cObject extends Record\u003cstring, any\u003e\u003e = {\r\n  [Property in keyof Object]?:\r\n    Object[Property] extends Record\u003cstring, any\u003e\r\n      ? DeepPartial\u003cObject[Property]\u003e\r\n      : Object[Property];\r\n};\r\n\r\ninterface Person {\r\n    name: {\r\n      first: string\r\n      last: string;\r\n    }\r\n    age: number\r\n}\r\ntype PartialPerson = DeepPartial\u003cPerson\u003e;\r\n\r\n// Results in:\r\n{\r\n  name?: {\r\n    first?: string\r\n    last?: string;\r\n  }\r\n  age?: number\r\n}\r\n```\r\n\r\n1. DeepPartial takes in 1 Generic parameter, `Object`, and we constrain it to be a plain JS object\r\n2. We extract the keys in `Object` using: `keyof Object`\r\n3. We then iterate over every key using the operator `in`, and assign the key to the variable `Property`\r\n4. We add a new field to the resulting object with an optional field: `[Property]?`\r\n5. We check if the value at `Object[Property]` is another object using: `Object[Property] extends Record\u003cstring, any\u003e ?`\r\n6. If it is an object, we recursively call `DeepPartial` on it\r\n7. Else, we just return the value at `Object[Property]`\r\n\r\n### Validation messages\r\n\r\nWe can even use conditional types to provide custom validation messages to arguments of a function!\r\n\r\n\u003e I don't recommend you add this complexity to your application code, but this would be useful if you maintain a library.\r\n\r\n```jsx\r\ntype Validate\u003c\r\n  Arg,\r\n  ExpectedType,\r\n  ErrorMsg extends string\r\n\u003e = Arg extends ExpectedType ? Arg : ErrorMsg;\r\n\r\nfunction sendMessage\u003cArg\u003e(\r\n  message: Validate\u003cArg, string, \"The message must be of type 'string'\"\u003e\r\n) {}\r\n\r\n// This won't compile!\r\n// Validate will return the specific type literal:\r\n//  \"The message must be of type 'string'\"\r\nsendMessage(1);\r\n\r\n// compiles without issues:\r\nsendMessage(\"hello\");\r\n```\r\n\r\n## Renaming Fields of an Object\r\n\r\nLet's say you need to add getter functions to an object, based on the existing fields in it.\r\nYou can use the `as` keyword when iterating over fields using `in`, to rename the existing fields:\r\n\r\n```jsx\r\ntype Getters\u003cObject extends Record\u003cstring, any\u003e\u003e = {\r\n  [Property in keyof Object as `get${Capitalize\u003c\r\n    string \u0026 Property\r\n  \u003e}`]: () =\u003e Object[Property];\r\n};\r\n\r\nconst person = {\r\n  name: \"John\",\r\n  age: 18,\r\n};\r\ntype PersonAsGetters = Getters\u003ctypeof person\u003e;\r\n\r\n// results in:\r\n{\r\n  getName: () =\u003e string;\r\n  getAge: () =\u003e number;\r\n}\r\n```\r\n\r\nNote: `Capitalize` is another inbuilt TypeScript utility.\r\n\r\n## Using `infer`\r\n\r\nYou use `infer` with conditional types in order to extract types to another generic variable.\r\nSeeing this in action would help you understand what the above means better.\r\n\r\n\u003e Remember, we can only use `infer` in the `extends` clause of a conditional type.\r\n\r\nHere's an example where I convert a string from `kebab-case` to `snake_case`:\r\n\r\n```jsx\r\ntype KebabToSnakeCase\u003cS extends string\u003e = S extends `${infer Char}${infer Rest}`\r\n  ? Char extends \"-\"\r\n    ? `_${KebabToSnakeCase\u003cRest\u003e}`\r\n    : `${Char}${KebabToSnakeCase\u003cRest\u003e}`\r\n  : S;\r\n\r\ntype Result = KebabToSnakeCase\u003c\"convert-this-kebab-case-to-snake-case\"\u003e;\r\n\r\n// results in:\r\n// \"convert_this_kebab_case_to_snake_case\";\r\n```\r\n\r\nWhat the following line:\r\n\r\n```jsx\r\nS extends `${infer Char}${infer Rest}`\r\n```\r\n\r\ndoes is that it checks if the generic `S` is a string that is of the template `${Char}${Rest}` - `Char` and `Rest` are named\r\ngeneric variables, and TypeScript will figure out what they are. If the string _does conform_ to it, `Char` will be the\r\nfirst character of a string, while `Rest` will be the remaining characters in the string.\r\n\r\nHere's another example where I extract the value from an object, given the dot-separated path - just like in Lodash's `get` utility:\r\n\r\n```jsx\r\ntype ExtractTypeFromPath\u003c\r\n  Path extends string,\r\n  Object extends Record\u003cstring, any\u003e\r\n\u003e = Path extends `${infer Property}.${infer RestOfPath}`\r\n  ? ExtractTypeFromPath\u003cRestOfPath, Object[Property]\u003e\r\n  : Object[Path];\r\n\r\ninterface Person {\r\n  data: {\r\n    firstName: string;\r\n    lastName: string;\r\n    sensitive: {\r\n      age: number;\r\n    };\r\n  };\r\n}\r\n// Results in number\r\ntype TypeOfAge = ExtractTypeFromPath\u003c\"data.sensitive.age\", Person\u003e;\r\n```\r\n\r\n## Dynamically inferring types from JavaScript\r\n\r\nIn the examples so far, we've been dealing exclusively with types - which have no\r\nimpact on the actual execution of our app - after all, the compiler just strips out\r\nall the type definitions.\r\n\r\nHowever, one of the most useful patterns I've found is to derive types from\r\nactual JavaScript objects. The trick is to use `Readonly` or `as const` to\r\nensure that the most accurate types would be derived.\r\n\r\nFor example, if you were to do this:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"];\r\n```\r\n\r\n`typeof fieldNames` would give you `string[]`\r\n\r\nHowever, if we did this instead:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\n```\r\n\r\nThis would give you `(\"name\" | \"age\")[]` - far more useful. We can then extract the values in the array using:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\ntype FieldName = typeof fieldNames[number];\r\n\r\n// results in: FieldName = \"name\" | \"age\"\r\n```\r\n\r\nBelow is an example of a situation where I used this approach. I needed to make a GET request\r\nto a REST API, and I could specify what fields in the data I want returned in the response. I simply\r\nhad to pass the field names as query parameters in the URL.\r\n\r\nRather than putting the field names as query parameters in a hard to read URL, I decided to put the fields I want\r\nin an array, then convert the array to the appropriate query parameters.\r\n\r\nHowever, TypeScript types become an issue - how does it know what the response object type is\r\nwhen it could change depending on what I put in the Javascript array?\r\n\r\nThis is how I did it:\r\n\r\n```jsx\r\nconst pickFields = [\"age\", \"name\", \"height\", \"isMember\"] as const;\r\n\r\ninterface ApiResponse {\r\n  age: number;\r\n  name: {\r\n    firstName: string;\r\n    lastName: string;\r\n  };\r\n  height: string;\r\n  isMember: boolean;\r\n}\r\n// Note that I'm not specifying pickFields is of type \"Array\u003ckeyof ApiResponse\u003e\"!\r\n\r\nasync function getPersonDetails\u003c\r\n  RequestedFields extends ReadonlyArray\u003ctypeof pickFields[number]\u003e\r\n\u003e(\r\n  ...fieldNames: RequestedFields\r\n): Promise\u003c{\r\n  [Field in RequestedFields extends ReadonlyArray\u003cinfer FieldNameValue\u003e\r\n    ? FieldNameValue\r\n    : never]: ApiResponse[Field];\r\n}\u003e {\r\n  return callRestApi(\"/v1/person\", fieldNames) as any;\r\n}\r\n\r\n// Will give you { age: number; isMember: boolean; height: string}\r\nconst response = await getPersonDetails(\"age\", \"isMember\", \"height\");\r\n```\r\n\r\nThis is the really cool part of making `pickFields` a `const` - TypeScript\r\ncan figure out from the signature of `getPersonDetails` that the values in\r\n`pickFields` **are a member of** `ApiResponse`!\r\n\r\nIf we put the string \"woof\" into `pickFields`, `getPersonDetails` will fail compilation with an error, because \"woof\" is not a field in `ApiResponse`!\r\n\r\nAnd if we put \"meow\" into the arguments of `getPersonDetails`, it will also fail for the same reason.\r\n"},"estimatedReadingTime":{"minutes":10,"words":1256,"text":"10 min read"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"favourite-typescript"},"buildId":"ucJQ1YAxIHSH9cRcLd6on","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>