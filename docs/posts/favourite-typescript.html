<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A blog on web development with React and Typescript."/><title>My Top TypeScript Tips</title><meta name="next-head-count" content="16"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/blog/_next/static/css/f2e8ce7a08454583.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/f2e8ce7a08454583.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/a7fa4402bacb9a02.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/a7fa4402bacb9a02.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-b4bc6d1b20a0a573.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ed62687b5581921b.js" defer=""></script><script src="/blog/_next/static/chunks/main-cb7b41c9cdc2a097.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f51201e12e7e4d94.js" defer=""></script><script src="/blog/_next/static/chunks/299-6b06e3596b88e631.js" defer=""></script><script src="/blog/_next/static/chunks/503-5f0d2c6f9d0a5f52.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-80fde88d01873cd0.js" defer=""></script><script src="/blog/_next/static/ao1_npWihaqzXY7d22P90/_buildManifest.js" defer=""></script><script src="/blog/_next/static/ao1_npWihaqzXY7d22P90/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Inter">@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZs.woff) format('woff')}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZJhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZthjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZNhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZxhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZBhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZFhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="bg-gray-900"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-lg md:text-xl font-bold underline text-teal-500 mb-20 pt-8"><a class="hover:text-sky-400" href="/blog">Home</a></h2><article id="blog-post" class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-pink-500 font-bold text-center text-6xl tracking-tighter leading-tight mx-auto md:text-left">My Top TypeScript Tips</h1><div class="mt-2 mb-6 text-lg text-white font-semibold"><div class="mb-1"><time dateTime="2022-10-01T20:00:00.000Z">October	2, 2022</time> |<!-- --> <span>Jithya Nanayakkara</span> |<!-- --> <span>10 min read</span></div><div><a class="text-base text-teal-500 underline hover:text-sky-400" href="#inject-comments-for-uterances">Jump to comments</a></div></div></div><section class="mx-auto max-w-md text-sm text-left text-gray-500 dark:text-gray-400 mb-2 rounded-lg"><h2 class="text-center font-semibold text-basis text-gray-700 uppercase bg-gray-50 dark:bg-gray-700 dark:text-gray-400 py-1.5 px-2.5">Table of Contents</h2><div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#creating-type-safe-utility-functions" class="underline text-gray-900 whitespace-nowrap dark:text-white">1<!-- -->. <!-- -->Creating type safe utility functions</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#conditional-types" class="underline text-gray-900 whitespace-nowrap dark:text-white">2<!-- -->. <!-- -->Conditional types</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#renaming-fields-of-an-object" class="underline text-gray-900 whitespace-nowrap dark:text-white">3<!-- -->. <!-- -->Renaming Fields of an Object</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#using" class="underline text-gray-900 whitespace-nowrap dark:text-white">4<!-- -->. <!-- -->Using `infer`</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#dynamically-inferring-types-from-javascript" class="underline text-gray-900 whitespace-nowrap dark:text-white">5<!-- -->. <!-- -->Dynamically inferring types from JavaScript</a></div></div></section><div class="max-w-2xl mx-auto text-gray-300"><div class="markdown-styles_markdown__8Ahqd"><p>This post covers a small collection of features and patterns I&#x27;ve found useful when working on TypeScript projects. Do note, what I&#x27;ve written is somewhat advanced, and isn&#x27;t particularly useful for beginners.</p>
<h2 level="2" node="[object Object]" id="creating-type-safe-utility-functions">Creating type safe utility functions</h2>
<p>There are times when certain libraries or APIs don&#x27;t have great type definitions, or unexpected types.
For example, you may have experienced the unpleasant suprise when <code class="bg-slate-800 px-2">Object.keys</code> returns a <code class="bg-slate-800 px-2">string[]</code> rather than the actual keys of the object (<a href="https://github.com/Microsoft/TypeScript/issues/12870">and this is the intended behaviour by the TypeScript authors</a>).</p>
<p>When you do come across this situation, don&#x27;t shy away from creating utility functions whose sole purpose is to get better types.
For the <code class="bg-slate-800 px-2">Object.keys</code> problem, I always create a type safe <code class="bg-slate-800 px-2">Object.keys</code> helper in my TypeScript projects, like this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function getObjectKeys&lt;Object extends Record&lt;string, any&gt;&gt;(
  obj: Object
): Array&lt;keyof Object&gt; {
  return Object.keys(obj);
}</code></div></pre>
<h2 level="2" node="[object Object]" id="conditional-types">Conditional types</h2>
<p>Conditional types essentially allow you to check if a type <code class="bg-slate-800 px-2">A</code>, is equal to, or is a subset of another type <code class="bg-slate-800 px-2">B</code>.
You use it in the form <code class="bg-slate-800 px-2">A extends B ? &lt;true-expression&gt; : &lt;false-expression&gt;</code>.</p>
<p>One example of where I use this, is when I create a <code class="bg-slate-800 px-2">DeepPartial</code> utility type - the inbuilt <code class="bg-slate-800 px-2">Partial</code> type only
makes the fields at the first level of an object optional, however <code class="bg-slate-800 px-2">DeepPartial</code> makes every field at every level of the object optional:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type DeepPartial&lt;Object extends Record&lt;string, any&gt;&gt; = {
  [Property in keyof Object]?:
    Object[Property] extends Record&lt;string, any&gt;
      ? DeepPartial&lt;Object[Property]&gt;
      : Object[Property];
};

interface Person {
    name: {
      first: string
      last: string;
    }
    age: number
}
type PartialPerson = DeepPartial&lt;Person&gt;;

// Results in:
{
  name?: {
    first?: string
    last?: string;
  }
  age?: number
}</code></div></pre>
<ol>
<li>DeepPartial takes in a Generic parameter, <code class="bg-slate-800 px-2">Object</code>, and we constrain it to be a plain JS object</li>
<li>We extract the keys in <code class="bg-slate-800 px-2">Object</code> using: <code class="bg-slate-800 px-2">keyof Object</code></li>
<li>We then iterate over every key using the operator <code class="bg-slate-800 px-2">in</code>, and assign the key to the variable <code class="bg-slate-800 px-2">Property</code></li>
<li>We add a new field to the resulting object with an optional field: <code class="bg-slate-800 px-2">[Property]?</code></li>
<li>We check if the value at <code class="bg-slate-800 px-2">Object[Property]</code> is another object using: <code class="bg-slate-800 px-2">Object[Property] extends Record&lt;string, any&gt; ?</code></li>
<li>If it is an object, we recursively call <code class="bg-slate-800 px-2">DeepPartial</code> on it</li>
<li>Else, we just return the value at <code class="bg-slate-800 px-2">Object[Property]</code></li>
</ol>
<h3>Validation messages</h3>
<p>Another place where I use conditional types, is to provide custom validation messages to arguments of a function.</p>
<blockquote>
<p>I don&#x27;t recommend you add this complexity to your application code, but this could be useful if you maintain a library.</p>
</blockquote>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type Validate&lt;
  Arg,
  ExpectedType,
  ErrorMsg extends string
&gt; = Arg extends ExpectedType ? Arg : ErrorMsg;

function sendMessage&lt;Arg&gt;(
  message: Validate&lt;Arg, string, &quot;The message must be of type &#x27;string&#x27;&quot;&gt;
) {}

// This won&#x27;t compile!
// Validate will return the specific type literal:
//  &quot;The message must be of type &#x27;string&#x27;&quot;
sendMessage(1);

// compiles without issues:
sendMessage(&quot;hello&quot;);</code></div></pre>
<h2 level="2" node="[object Object]" id="renaming-fields-of-an-object">Renaming Fields of an Object</h2>
<p>Let&#x27;s say you need to add getter functions to an object, based on the existing fields in it.
You can use the <code class="bg-slate-800 px-2">as</code> keyword when iterating over fields using <code class="bg-slate-800 px-2">in</code>, to rename the existing fields:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type Getters&lt;Object extends Record&lt;string, any&gt;&gt; = {
  [Property in keyof Object as `get${Capitalize&lt;
    string &amp; Property
  &gt;}`]: () =&gt; Object[Property];
};

const person = {
  name: &quot;John&quot;,
  age: 18,
};
type PersonAsGetters = Getters&lt;typeof person&gt;;

// results in:
{
  getName: () =&gt; string;
  getAge: () =&gt; number;
}</code></div></pre>
<p>Note: <code class="bg-slate-800 px-2">Capitalize</code> is another inbuilt TypeScript utility.</p>
<h2 level="2" node="[object Object]" id="using">Using <code class="bg-slate-800 px-2">infer</code></h2>
<p><code class="bg-slate-800 px-2">infer</code> is used with conditional types in order to extract types in the condition to another generic variable.
This is not something I particularly understand or can explain well, but I find looking at a couple of examples
is more helpful in understanding <code class="bg-slate-800 px-2">infer</code>.</p>
<blockquote>
<p>Remember, we can only use <code class="bg-slate-800 px-2">infer</code> in the <code class="bg-slate-800 px-2">extends</code> clause of a conditional type.</p>
</blockquote>
<p>Here&#x27;s an example where I convert a string from <code class="bg-slate-800 px-2">kebab-case</code> to <code class="bg-slate-800 px-2">snake_case</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type KebabToSnakeCase&lt;S extends string&gt; = S extends `${infer Char}${infer Rest}`
  ? Char extends &quot;-&quot;
    ? `_${KebabToSnakeCase&lt;Rest&gt;}`
    : `${Char}${KebabToSnakeCase&lt;Rest&gt;}`
  : S;

type Result = KebabToSnakeCase&lt;&quot;convert-this-kebab-case-to-snake-case&quot;&gt;;
// Gives: &quot;convert_this_kebab_case_to_snake_case&quot;;
</code></div></pre>
<p>What the following line:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">S extends `${infer Char}${infer Rest}`</code></div></pre>
<p>does is that it checks if the generic <code class="bg-slate-800 px-2">S</code> is a string that is of the template <code class="bg-slate-800 px-2">${Char}${Rest}</code> - <code class="bg-slate-800 px-2">Char</code> and <code class="bg-slate-800 px-2">Rest</code> are named
generic variables, and TypeScript will figure out what they are. If the string <em>does conform</em> to it, <code class="bg-slate-800 px-2">Char</code> will be the
first character of a string, while <code class="bg-slate-800 px-2">Rest</code> will be the remaining characters in the string.</p>
<p>Here&#x27;s another example where I extract the value from an object, given the dot-separated path - just like in Lodash&#x27;s <code class="bg-slate-800 px-2">get</code> utility:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type ExtractTypeFromPath&lt;
  Path extends string,
  Object extends Record&lt;string, any&gt;
&gt; = Path extends `${infer Property}.${infer RestOfPath}`
  ? ExtractTypeFromPath&lt;RestOfPath, Object[Property]&gt;
  : Object[Path];

interface Person {
  data: {
    firstName: string;
    lastName: string;
    sensitive: {
      age: number;
    };
  };
}
// Results in number
type TypeOfAge = ExtractTypeFromPath&lt;&quot;data.sensitive.age&quot;, Person&gt;;</code></div></pre>
<h2 level="2" node="[object Object]" id="dynamically-inferring-types-from-javascript">Dynamically inferring types from JavaScript</h2>
<p>In the examples so far, we&#x27;ve been dealing exclusively with types - which have no
impact on the actual execution of our app - after all, the compiler just strips out
all the type definitions.</p>
<p>However, one of the most useful patterns I&#x27;ve found is to derive types from
actual JavaScript objects. The trick is to use <code class="bg-slate-800 px-2">as const</code> to
ensure that the most accurate types would be derived.</p>
<p>For example, if you were to do this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;];</code></div></pre>
<p><code class="bg-slate-800 px-2">typeof fieldNames</code> would give you <code class="bg-slate-800 px-2">string[]</code></p>
<p>However, if we did this instead:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;] as const;</code></div></pre>
<p>This would give you <code class="bg-slate-800 px-2">(&quot;name&quot; | &quot;age&quot;)[]</code> - which is far more useful. We can then extract the values in the array using:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;] as const;
type FieldName = typeof fieldNames[number];

// results in: FieldName = &quot;name&quot; | &quot;age&quot;</code></div></pre>
<p>Below is an example of a situation where I used this approach. My memory of it is rather hazy, but from what I recall,
I needed to make a GET request
to a REST API, and I could specify what fields in the data I want returned in the response. I simply
had to pass the field names as query parameters in the URL (in a comma separated format).</p>
<p>Rather than putting the field names as query parameters in a hard to read URL, I decided to put the fields I want
in an array, then convert the array to the appropriate query parameters. This was quite useful, because I discovered in production
that there were multiple other field names with the data I needed, and I could easily add them to the array over time.</p>
<p>However, TypeScript types become an issue - how does it know what the response object type is
given my JavaScript array?</p>
<p>This is how I did it:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const pickFields = [&quot;age&quot;, &quot;isMember&quot;] as const;

interface ApiResponse {
  age: number;
  name: {
    firstName: string;
    lastName: string;
  };
  height: string;
  isMember: boolean;
}
// Note that I&#x27;m not specifying pickFields
// is of type &quot;Array&lt;keyof ApiResponse&gt;&quot;!

/**
 * I&#x27;m constraining it to only the fields I&#x27;m interested in
 */
async function getPersonDetails&lt;
  RequestedFields extends ReadonlyArray&lt;typeof pickFields[number]&gt;
&gt;(
  ...fieldNames: RequestedFields
): Promise&lt;{
  [Field in RequestedFields extends ReadonlyArray&lt;infer FieldNameValue&gt;
    ? FieldNameValue
    : never]: ApiResponse[Field];
}&gt; {
  return callRestApi(&quot;/v1/person&quot;, fieldNames) as any;
}

// Will give you { age: number; isMember: boolean; }
const response = await getPersonDetails(...pickFields)</code></div></pre>
<p>This is the really cool part of making <code class="bg-slate-800 px-2">pickFields</code> a <code class="bg-slate-800 px-2">const</code> - TypeScript
can figure out that the values in <code class="bg-slate-800 px-2">pickFields</code> <strong>are a member of</strong> <code class="bg-slate-800 px-2">ApiResponse</code>!</p>
<p>If we put the string &quot;woof&quot; into <code class="bg-slate-800 px-2">pickFields</code>, <code class="bg-slate-800 px-2">getPersonDetails</code> will fail compilation with an error, because &quot;woof&quot; is not a field in <code class="bg-slate-800 px-2">ApiResponse</code>!</p>
<p>Likewise, putting it into the arguments of <code class="bg-slate-800 px-2">getPersonDetails</code>, will also fail compilation for the same reason.</p></div></div><section><div id="inject-comments-for-uterances"></div></section></article></div></main></div><footer class="bg-slate-800"><div style="display:table" class="mx-auto"><ul class="list-none flex flex-row text-lg text-teal-500 underline font-semibold p-2"><li class="mr-4 max-w-md"><a href="https://github.com/jithyan" class="hover:text-sky-400 " target="_blank">Github</a></li><li class="mr-4 max-w-md"><a href="https://www.linkedin.com/in/jithyan/" class=" hover:text-sky-400 " target="_blank">LinkedIn</a></li><li class=""><a href="https://jithyan.github.io/resume/" class=" hover:text-sky-400" target="_blank">Resume</a></li></ul></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"My Top TypeScript Tips","date":"2022-10-01T20:00:00.000Z","slug":"favourite-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\r\nThis post covers a small collection of features and patterns I've found useful when working on TypeScript projects. Do note, what I've written is somewhat advanced, and isn't particularly useful for beginners.\r\n\r\n## Creating type safe utility functions\r\n\r\nThere are times when certain libraries or APIs don't have great type definitions, or unexpected types.\r\nFor example, you may have experienced the unpleasant suprise when `Object.keys` returns a `string[]` rather than the actual keys of the object ([and this is the intended behaviour by the TypeScript authors](https://github.com/Microsoft/TypeScript/issues/12870)).\r\n\r\nWhen you do come across this situation, don't shy away from creating utility functions whose sole purpose is to get better types.\r\nFor the `Object.keys` problem, I always create a type safe `Object.keys` helper in my TypeScript projects, like this:\r\n\r\n```jsx\r\nfunction getObjectKeys\u003cObject extends Record\u003cstring, any\u003e\u003e(\r\n  obj: Object\r\n): Array\u003ckeyof Object\u003e {\r\n  return Object.keys(obj);\r\n}\r\n```\r\n\r\n## Conditional types\r\n\r\nConditional types essentially allow you to check if a type `A`, is equal to, or is a subset of another type `B`.\r\nYou use it in the form `A extends B ? \u003ctrue-expression\u003e : \u003cfalse-expression\u003e`.\r\n\r\nOne example of where I use this, is when I create a `DeepPartial` utility type - the inbuilt `Partial` type only\r\nmakes the fields at the first level of an object optional, however `DeepPartial` makes every field at every level of the object optional:\r\n\r\n```jsx\r\ntype DeepPartial\u003cObject extends Record\u003cstring, any\u003e\u003e = {\r\n  [Property in keyof Object]?:\r\n    Object[Property] extends Record\u003cstring, any\u003e\r\n      ? DeepPartial\u003cObject[Property]\u003e\r\n      : Object[Property];\r\n};\r\n\r\ninterface Person {\r\n    name: {\r\n      first: string\r\n      last: string;\r\n    }\r\n    age: number\r\n}\r\ntype PartialPerson = DeepPartial\u003cPerson\u003e;\r\n\r\n// Results in:\r\n{\r\n  name?: {\r\n    first?: string\r\n    last?: string;\r\n  }\r\n  age?: number\r\n}\r\n```\r\n\r\n1. DeepPartial takes in a Generic parameter, `Object`, and we constrain it to be a plain JS object\r\n2. We extract the keys in `Object` using: `keyof Object`\r\n3. We then iterate over every key using the operator `in`, and assign the key to the variable `Property`\r\n4. We add a new field to the resulting object with an optional field: `[Property]?`\r\n5. We check if the value at `Object[Property]` is another object using: `Object[Property] extends Record\u003cstring, any\u003e ?`\r\n6. If it is an object, we recursively call `DeepPartial` on it\r\n7. Else, we just return the value at `Object[Property]`\r\n\r\n### Validation messages\r\n\r\nAnother place where I use conditional types, is to provide custom validation messages to arguments of a function.\r\n\r\n\u003e I don't recommend you add this complexity to your application code, but this could be useful if you maintain a library.\r\n\r\n```jsx\r\ntype Validate\u003c\r\n  Arg,\r\n  ExpectedType,\r\n  ErrorMsg extends string\r\n\u003e = Arg extends ExpectedType ? Arg : ErrorMsg;\r\n\r\nfunction sendMessage\u003cArg\u003e(\r\n  message: Validate\u003cArg, string, \"The message must be of type 'string'\"\u003e\r\n) {}\r\n\r\n// This won't compile!\r\n// Validate will return the specific type literal:\r\n//  \"The message must be of type 'string'\"\r\nsendMessage(1);\r\n\r\n// compiles without issues:\r\nsendMessage(\"hello\");\r\n```\r\n\r\n## Renaming Fields of an Object\r\n\r\nLet's say you need to add getter functions to an object, based on the existing fields in it.\r\nYou can use the `as` keyword when iterating over fields using `in`, to rename the existing fields:\r\n\r\n```jsx\r\ntype Getters\u003cObject extends Record\u003cstring, any\u003e\u003e = {\r\n  [Property in keyof Object as `get${Capitalize\u003c\r\n    string \u0026 Property\r\n  \u003e}`]: () =\u003e Object[Property];\r\n};\r\n\r\nconst person = {\r\n  name: \"John\",\r\n  age: 18,\r\n};\r\ntype PersonAsGetters = Getters\u003ctypeof person\u003e;\r\n\r\n// results in:\r\n{\r\n  getName: () =\u003e string;\r\n  getAge: () =\u003e number;\r\n}\r\n```\r\n\r\nNote: `Capitalize` is another inbuilt TypeScript utility.\r\n\r\n## Using `infer`\r\n\r\n`infer` is used with conditional types in order to extract types in the condition to another generic variable.\r\nThis is not something I particularly understand or can explain well, but I find looking at a couple of examples\r\nis more helpful in understanding `infer`.\r\n\r\n\u003e Remember, we can only use `infer` in the `extends` clause of a conditional type.\r\n\r\nHere's an example where I convert a string from `kebab-case` to `snake_case`:\r\n\r\n```jsx\r\ntype KebabToSnakeCase\u003cS extends string\u003e = S extends `${infer Char}${infer Rest}`\r\n  ? Char extends \"-\"\r\n    ? `_${KebabToSnakeCase\u003cRest\u003e}`\r\n    : `${Char}${KebabToSnakeCase\u003cRest\u003e}`\r\n  : S;\r\n\r\ntype Result = KebabToSnakeCase\u003c\"convert-this-kebab-case-to-snake-case\"\u003e;\r\n// Gives: \"convert_this_kebab_case_to_snake_case\";\r\n\r\n```\r\n\r\nWhat the following line:\r\n\r\n```jsx\r\nS extends `${infer Char}${infer Rest}`\r\n```\r\n\r\ndoes is that it checks if the generic `S` is a string that is of the template `${Char}${Rest}` - `Char` and `Rest` are named\r\ngeneric variables, and TypeScript will figure out what they are. If the string _does conform_ to it, `Char` will be the\r\nfirst character of a string, while `Rest` will be the remaining characters in the string.\r\n\r\nHere's another example where I extract the value from an object, given the dot-separated path - just like in Lodash's `get` utility:\r\n\r\n```jsx\r\ntype ExtractTypeFromPath\u003c\r\n  Path extends string,\r\n  Object extends Record\u003cstring, any\u003e\r\n\u003e = Path extends `${infer Property}.${infer RestOfPath}`\r\n  ? ExtractTypeFromPath\u003cRestOfPath, Object[Property]\u003e\r\n  : Object[Path];\r\n\r\ninterface Person {\r\n  data: {\r\n    firstName: string;\r\n    lastName: string;\r\n    sensitive: {\r\n      age: number;\r\n    };\r\n  };\r\n}\r\n// Results in number\r\ntype TypeOfAge = ExtractTypeFromPath\u003c\"data.sensitive.age\", Person\u003e;\r\n```\r\n\r\n## Dynamically inferring types from JavaScript\r\n\r\nIn the examples so far, we've been dealing exclusively with types - which have no\r\nimpact on the actual execution of our app - after all, the compiler just strips out\r\nall the type definitions.\r\n\r\nHowever, one of the most useful patterns I've found is to derive types from\r\nactual JavaScript objects. The trick is to use `as const` to\r\nensure that the most accurate types would be derived.\r\n\r\nFor example, if you were to do this:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"];\r\n```\r\n\r\n`typeof fieldNames` would give you `string[]`\r\n\r\nHowever, if we did this instead:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\n```\r\n\r\nThis would give you `(\"name\" | \"age\")[]` - which is far more useful. We can then extract the values in the array using:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\ntype FieldName = typeof fieldNames[number];\r\n\r\n// results in: FieldName = \"name\" | \"age\"\r\n```\r\n\r\nBelow is an example of a situation where I used this approach. My memory of it is rather hazy, but from what I recall,\r\nI needed to make a GET request\r\nto a REST API, and I could specify what fields in the data I want returned in the response. I simply\r\nhad to pass the field names as query parameters in the URL (in a comma separated format).\r\n\r\nRather than putting the field names as query parameters in a hard to read URL, I decided to put the fields I want\r\nin an array, then convert the array to the appropriate query parameters. This was quite useful, because I discovered in production\r\nthat there were multiple other field names with the data I needed, and I could easily add them to the array over time.\r\n\r\nHowever, TypeScript types become an issue - how does it know what the response object type is\r\ngiven my JavaScript array?\r\n\r\nThis is how I did it:\r\n\r\n```jsx\r\nconst pickFields = [\"age\", \"isMember\"] as const;\r\n\r\ninterface ApiResponse {\r\n  age: number;\r\n  name: {\r\n    firstName: string;\r\n    lastName: string;\r\n  };\r\n  height: string;\r\n  isMember: boolean;\r\n}\r\n// Note that I'm not specifying pickFields\r\n// is of type \"Array\u003ckeyof ApiResponse\u003e\"!\r\n\r\n/**\r\n * I'm constraining it to only the fields I'm interested in\r\n */\r\nasync function getPersonDetails\u003c\r\n  RequestedFields extends ReadonlyArray\u003ctypeof pickFields[number]\u003e\r\n\u003e(\r\n  ...fieldNames: RequestedFields\r\n): Promise\u003c{\r\n  [Field in RequestedFields extends ReadonlyArray\u003cinfer FieldNameValue\u003e\r\n    ? FieldNameValue\r\n    : never]: ApiResponse[Field];\r\n}\u003e {\r\n  return callRestApi(\"/v1/person\", fieldNames) as any;\r\n}\r\n\r\n// Will give you { age: number; isMember: boolean; }\r\nconst response = await getPersonDetails(...pickFields)\r\n```\r\n\r\nThis is the really cool part of making `pickFields` a `const` - TypeScript\r\ncan figure out that the values in `pickFields` **are a member of** `ApiResponse`!\r\n\r\nIf we put the string \"woof\" into `pickFields`, `getPersonDetails` will fail compilation with an error, because \"woof\" is not a field in `ApiResponse`!\r\n\r\nLikewise, putting it into the arguments of `getPersonDetails`, will also fail compilation for the same reason.\r\n"},"estimatedReadingTime":{"minutes":10,"words":1279,"text":"10 min read"},"headings":["Creating type safe utility functions","Conditional types","Renaming Fields of an Object","Using `infer`","Dynamically inferring types from JavaScript"]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"favourite-typescript"},"buildId":"ao1_npWihaqzXY7d22P90","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>