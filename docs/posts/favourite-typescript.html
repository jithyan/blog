<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A blog on web development with React and Typescript."/><title>Useful Advanced Typescript Features</title><meta name="next-head-count" content="16"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/blog/_next/static/css/f2e8ce7a08454583.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/f2e8ce7a08454583.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/ff77306449b1897a.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/ff77306449b1897a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-5f0cf5446be11543.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ed62687b5581921b.js" defer=""></script><script src="/blog/_next/static/chunks/main-cb7b41c9cdc2a097.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f51201e12e7e4d94.js" defer=""></script><script src="/blog/_next/static/chunks/299-6b06e3596b88e631.js" defer=""></script><script src="/blog/_next/static/chunks/503-5f0d2c6f9d0a5f52.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-4f495f5866c95a35.js" defer=""></script><script src="/blog/_next/static/OHDaK1tubpGiXm7rSbjcv/_buildManifest.js" defer=""></script><script src="/blog/_next/static/OHDaK1tubpGiXm7rSbjcv/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Inter">@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZs.woff) format('woff')}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZJhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZthjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZNhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZxhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZBhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZFhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="bg-gray-900"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-lg md:text-xl font-bold underline text-teal-500 mb-20 pt-8"><a class="hover:text-sky-400" href="/blog">Home</a></h2><article id="blog-post" class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-pink-500 font-bold text-center text-6xl tracking-tighter leading-tight mx-auto md:text-left">Useful Advanced Typescript Features</h1><div class="mt-2 mb-6 text-lg text-white font-semibold"><div class="mb-1"><time dateTime="2022-10-01T20:00:00.000Z">October	2, 2022</time> |<!-- --> <span>Jithya Nanayakkara</span> |<!-- --> <span>9 min read</span></div><div><a class="text-base text-teal-500 underline hover:text-sky-400" href="#inject-comments-for-uterances">Jump to comments</a></div></div></div><section class="mx-auto max-w-md text-sm text-left text-gray-500 dark:text-gray-400 mb-2 rounded-lg"><h2 class="text-center font-semibold text-basis text-gray-700 uppercase bg-gray-50 dark:bg-gray-700 dark:text-gray-400 py-1.5 px-2.5">Table of Contents</h2><div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#creating-type-safe-utility-functions" class="underline text-gray-900 whitespace-nowrap dark:text-white">1<!-- -->. <!-- -->Creating type safe utility functions</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#conditional-types" class="underline text-gray-900 whitespace-nowrap dark:text-white">2<!-- -->. <!-- -->Conditional types</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#renaming-fields-of-an-object" class="underline text-gray-900 whitespace-nowrap dark:text-white">3<!-- -->. <!-- -->Renaming Fields of an Object</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#using" class="underline text-gray-900 whitespace-nowrap dark:text-white">4<!-- -->. <!-- -->Using `infer`</a></div><div class="bg-white border-b dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-pink-400 py-2 px-3 "><a href="#dynamically-inferring-types-from-javascript" class="underline text-gray-900 whitespace-nowrap dark:text-white">5<!-- -->. <!-- -->Dynamically inferring types from JavaScript</a></div></div></section><div class="max-w-2xl mx-auto text-gray-300"><div class="markdown-styles_markdown__8Ahqd"><p>This post covers a small collection of features and patterns I&#x27;ve found useful when working on TypeScript projects. Do note, what I&#x27;ve written is somewhat advanced, and isn&#x27;t particularly useful for beginners.</p>
<h2 level="2" node="[object Object]" id="creating-type-safe-utility-functions">Creating type safe utility functions</h2>
<p>There are times when certain libraries or APIs don&#x27;t have great type definitions, or unexpected types.
For example, you may have experienced the unpleasant suprise when <code class="bg-slate-800 px-2">Object.keys</code> returns a <code class="bg-slate-800 px-2">string[]</code> rather than the actual keys of the object (<a href="https://github.com/Microsoft/TypeScript/issues/12870">and this is the intended behaviour by the TypeScript authors</a>).</p>
<p>When you do come across this situation, don&#x27;t shy away from creating utility functions whose sole purpose is to get better types.
For the <code class="bg-slate-800 px-2">Object.keys</code> problem, I always create a type safe <code class="bg-slate-800 px-2">Object.keys</code> helper in my TypeScript projects, like this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function getObjectKeys&lt;Object extends Record&lt;string, any&gt;&gt;(
  obj: Object
): Array&lt;keyof Object&gt; {
  return Object.keys(obj);
}</code></div></pre>
<h2 level="2" node="[object Object]" id="conditional-types">Conditional types</h2>
<p>Conditional types essentially allow you to check if a type <code class="bg-slate-800 px-2">A</code>, is equal to, or is a subset of another type <code class="bg-slate-800 px-2">B</code>.
You use it in the form <code class="bg-slate-800 px-2">A extends B ? &lt;true-expression&gt; : &lt;false-expression&gt;</code>.</p>
<p>One example of where I use this, is when I create a <code class="bg-slate-800 px-2">DeepPartial</code> utility type - the inbuilt <code class="bg-slate-800 px-2">Partial</code> type only
makes the fields at the first level of an object optional, however <code class="bg-slate-800 px-2">DeepPartial</code> makes every field at every level of the object optional:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type DeepPartial&lt;Object extends Record&lt;string, any&gt;&gt; = {
  [Property in keyof Object]?:
    Object[Property] extends Record&lt;string, any&gt;
      ? DeepPartial&lt;Object[Property]&gt;
      : Object[Property];
};

interface Person {
    name: {
      first: string
      last: string;
    }
    age: number
}
type PartialPerson = DeepPartial&lt;Person&gt;;

// Results in:
{
  name?: {
    first?: string
    last?: string;
  }
  age?: number
}</code></div></pre>
<ol>
<li>DeepPartial takes in a Generic parameter, <code class="bg-slate-800 px-2">Object</code>, and we constrain it to be a plain JS object</li>
<li>We extract the keys in <code class="bg-slate-800 px-2">Object</code> using: <code class="bg-slate-800 px-2">keyof Object</code></li>
<li>We then iterate over every key using the operator <code class="bg-slate-800 px-2">in</code>, and assign the key to the variable <code class="bg-slate-800 px-2">Property</code></li>
<li>We add a new field to the resulting object with an optional field: <code class="bg-slate-800 px-2">[Property]?</code></li>
<li>We check if the value at <code class="bg-slate-800 px-2">Object[Property]</code> is another object using: <code class="bg-slate-800 px-2">Object[Property] extends Record&lt;string, any&gt; ?</code></li>
<li>If it is an object, we recursively call <code class="bg-slate-800 px-2">DeepPartial</code> on it</li>
<li>Else, we just return the value at <code class="bg-slate-800 px-2">Object[Property]</code></li>
</ol>
<h3>Validation messages</h3>
<p>Another place where I use conditional types, is to provide custom validation messages to arguments of a function.</p>
<blockquote>
<p>I don&#x27;t recommend you add this complexity to your application code, but this could be useful if you maintain a library.</p>
</blockquote>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type Validate&lt;
  Arg,
  ExpectedType,
  ErrorMsg extends string
&gt; = Arg extends ExpectedType ? Arg : ErrorMsg;

function sendMessage&lt;Arg&gt;(
  message: Validate&lt;Arg, string, &quot;The message must be of type &#x27;string&#x27;&quot;&gt;
) {}

// This won&#x27;t compile!
// Validate will return the specific type literal:
//  &quot;The message must be of type &#x27;string&#x27;&quot;
sendMessage(1);

// compiles without issues:
sendMessage(&quot;hello&quot;);</code></div></pre>
<h2 level="2" node="[object Object]" id="renaming-fields-of-an-object">Renaming Fields of an Object</h2>
<p>Let&#x27;s say you want to create a new object, whose keys are the same as another object, but <em>in uppercase</em>.
You can use the <code class="bg-slate-800 px-2">as</code> keyword when iterating over fields using <code class="bg-slate-800 px-2">in</code>, to rename the existing fields:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const some_constants = {
  max_age: 100,
  minimum_age: 0,
  country_of_residence: &quot;AU&quot;
};

type SomeConstantsInUppercase = {
  [Property in keyof typeof some_constants as Uppercase&lt;Property&gt;]: typeof some_constants[Property];
}

// results in:
{
  MAX_AGE: 100,
  MINIMUM_AGE: 0,
  COUNTRY_OF_RESIDENCE: &quot;AU&quot;
}</code></div></pre>
<p>Note: <code class="bg-slate-800 px-2">Uppercase</code> is another inbuilt TypeScript utility.</p>
<h2 level="2" node="[object Object]" id="using">Using <code class="bg-slate-800 px-2">infer</code></h2>
<p><code class="bg-slate-800 px-2">infer</code> is something I confess to not understand very well. However I have found it useful when creating more complex types
and I find looking at some examples helpful in understanding how to use it.</p>
<p><code class="bg-slate-800 px-2">infer</code> is used with conditional types in order to extract types in the condition and assign it to another generic variable.
The golden rule to remember when using <code class="bg-slate-800 px-2">infer</code> is:</p>
<blockquote>
<p><code class="bg-slate-800 px-2">infer</code> can only be used in the <code class="bg-slate-800 px-2">extends</code> clause of a <em>conditional</em> type.</p>
</blockquote>
<p>Here&#x27;s an example where I convert a string from <code class="bg-slate-800 px-2">kebab-case</code> to <code class="bg-slate-800 px-2">snake_case</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type KebabToSnakeCase&lt;S extends string&gt; = S extends `${infer Char}${infer Rest}`
  ? Char extends &quot;-&quot;
    ? `_${KebabToSnakeCase&lt;Rest&gt;}`
    : `${Char}${KebabToSnakeCase&lt;Rest&gt;}`
  : S;

type Result = KebabToSnakeCase&lt;&quot;convert-this-kebab-case-to-snake-case&quot;&gt;;

// Gives: &quot;convert_this_kebab_case_to_snake_case&quot;</code></div></pre>
<p>What the following line:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">S extends `${infer Char}${infer Rest}`</code></div></pre>
<p>does is that it checks if the generic <code class="bg-slate-800 px-2">S</code> is a string that is of the template <code class="bg-slate-800 px-2">${Char}${Rest}</code> - <code class="bg-slate-800 px-2">Char</code> and <code class="bg-slate-800 px-2">Rest</code> are named
generic variables, and TypeScript will figure out what they are. If the string <em>does conform</em> to it, <code class="bg-slate-800 px-2">Char</code> will be the
first character of a string, while <code class="bg-slate-800 px-2">Rest</code> will be the remaining characters in the string.</p>
<p>Here&#x27;s another example where I extract the value from an object, given the dot-separated path - just like in Lodash&#x27;s <code class="bg-slate-800 px-2">get</code> utility:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">type ExtractTypeFromPath&lt;
  Path extends string,
  Object extends Record&lt;string, any&gt;
&gt; = Path extends `${infer Property}.${infer RestOfPath}`
  ? ExtractTypeFromPath&lt;RestOfPath, Object[Property]&gt;
  : Object[Path];

interface Person {
  data: {
    firstName: string;
    lastName: string;
    sensitive: {
      age: number;
    };
  };
}
// Results in number
type TypeOfAge = ExtractTypeFromPath&lt;&quot;data.sensitive.age&quot;, Person&gt;;</code></div></pre>
<h2 level="2" node="[object Object]" id="dynamically-inferring-types-from-javascript">Dynamically inferring types from JavaScript</h2>
<p>In the examples so far, we&#x27;ve been dealing exclusively with types - which have no
impact on the actual execution of our app - after all, the compiler just strips out
all the type definitions.</p>
<p>However, one of the most useful patterns I&#x27;ve found is to derive types from
actual JavaScript objects. The trick is to use <code class="bg-slate-800 px-2">as const</code> to
ensure that the most accurate types would be derived.</p>
<p>For example, if you were to do this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;];</code></div></pre>
<p><code class="bg-slate-800 px-2">typeof fieldNames</code> would give you <code class="bg-slate-800 px-2">string[]</code></p>
<p>However, if we did this instead:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;] as const;</code></div></pre>
<p>This would give you <code class="bg-slate-800 px-2">(&quot;name&quot; | &quot;age&quot;)[]</code> - which is far more useful. We can then extract the values in the array using:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldNames = [&quot;name&quot;, &quot;age&quot;] as const;
type FieldName = typeof fieldNames[number];

// results in: FieldName = &quot;name&quot; | &quot;age&quot;</code></div></pre>
<p>A very simplified example of how this can be useful, is when you want to specify in <em>JavaScript</em> what fields a REST API endpoint
should return.</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const fieldsToFetch = [&quot;first_name&quot;, &quot;last_name&quot;, &quot;dob&quot;, &quot;country&quot;] as const;

async function someRestAPICall&lt;Fields extends typeof fieldsToFetch&gt;(
    fields: Fields
): Promise&lt;{ [Property in Fields[number]]: string }&gt; {
  // call endpoint and return JSON data
}

const response = await someRestAPICall(fieldsToFetch);

// The type of response would be:
{
  first_name: string;
  last_name: string;
  dob: string;
  country: string;
}</code></div></pre>
<p>So if you want to change which fields to request from the REST API, you just update <code class="bg-slate-800 px-2">fieldsToFetch</code>, and the
response would <code class="bg-slate-800 px-2">automatically</code> update to the correct type.</p>
<p>For example, if you removed <code class="bg-slate-800 px-2">&quot;last_name&quot;</code>, and somewhere in the application you referred to <code class="bg-slate-800 px-2">response.last_name</code>, Typescript will fail to compile with an error!</p>
<blockquote>
<p>Update: As of Typescript 4.9, you can use the <code class="bg-slate-800 px-2">satisfies</code> operator to enforce additional type safety when defining <code class="bg-slate-800 px-2">as const</code> objects. Read this article for more info on <code class="bg-slate-800 px-2">satisfies</code>: <a href="https://www.totaltypescript.com/clarifying-the-satisfies-operator">https://www.totaltypescript.com/clarifying-the-satisfies-operator</a></p>
</blockquote></div></div><section><div id="inject-comments-for-uterances"></div></section></article></div></main></div><footer class="bg-slate-800"><div style="display:table" class="mx-auto"><ul class="list-none flex flex-row text-lg text-teal-500 underline font-semibold p-2"><li class="mr-4 max-w-md"><a href="https://github.com/jithyan" class="hover:text-sky-400 " target="_blank">Github</a></li><li class="mr-4 max-w-md"><a href="https://www.linkedin.com/in/jithyan/" class=" hover:text-sky-400 " target="_blank">LinkedIn</a></li><li class=""><a href="https://jithyan.github.io/resume/" class=" hover:text-sky-400" target="_blank">Resume</a></li></ul></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Useful Advanced Typescript Features","date":"2022-10-01T20:00:00.000Z","slug":"favourite-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\r\nThis post covers a small collection of features and patterns I've found useful when working on TypeScript projects. Do note, what I've written is somewhat advanced, and isn't particularly useful for beginners.\r\n\r\n## Creating type safe utility functions\r\n\r\nThere are times when certain libraries or APIs don't have great type definitions, or unexpected types.\r\nFor example, you may have experienced the unpleasant suprise when `Object.keys` returns a `string[]` rather than the actual keys of the object ([and this is the intended behaviour by the TypeScript authors](https://github.com/Microsoft/TypeScript/issues/12870)).\r\n\r\nWhen you do come across this situation, don't shy away from creating utility functions whose sole purpose is to get better types.\r\nFor the `Object.keys` problem, I always create a type safe `Object.keys` helper in my TypeScript projects, like this:\r\n\r\n```jsx\r\nfunction getObjectKeys\u003cObject extends Record\u003cstring, any\u003e\u003e(\r\n  obj: Object\r\n): Array\u003ckeyof Object\u003e {\r\n  return Object.keys(obj);\r\n}\r\n```\r\n\r\n## Conditional types\r\n\r\nConditional types essentially allow you to check if a type `A`, is equal to, or is a subset of another type `B`.\r\nYou use it in the form `A extends B ? \u003ctrue-expression\u003e : \u003cfalse-expression\u003e`.\r\n\r\nOne example of where I use this, is when I create a `DeepPartial` utility type - the inbuilt `Partial` type only\r\nmakes the fields at the first level of an object optional, however `DeepPartial` makes every field at every level of the object optional:\r\n\r\n```jsx\r\ntype DeepPartial\u003cObject extends Record\u003cstring, any\u003e\u003e = {\r\n  [Property in keyof Object]?:\r\n    Object[Property] extends Record\u003cstring, any\u003e\r\n      ? DeepPartial\u003cObject[Property]\u003e\r\n      : Object[Property];\r\n};\r\n\r\ninterface Person {\r\n    name: {\r\n      first: string\r\n      last: string;\r\n    }\r\n    age: number\r\n}\r\ntype PartialPerson = DeepPartial\u003cPerson\u003e;\r\n\r\n// Results in:\r\n{\r\n  name?: {\r\n    first?: string\r\n    last?: string;\r\n  }\r\n  age?: number\r\n}\r\n```\r\n\r\n1. DeepPartial takes in a Generic parameter, `Object`, and we constrain it to be a plain JS object\r\n2. We extract the keys in `Object` using: `keyof Object`\r\n3. We then iterate over every key using the operator `in`, and assign the key to the variable `Property`\r\n4. We add a new field to the resulting object with an optional field: `[Property]?`\r\n5. We check if the value at `Object[Property]` is another object using: `Object[Property] extends Record\u003cstring, any\u003e ?`\r\n6. If it is an object, we recursively call `DeepPartial` on it\r\n7. Else, we just return the value at `Object[Property]`\r\n\r\n### Validation messages\r\n\r\nAnother place where I use conditional types, is to provide custom validation messages to arguments of a function.\r\n\r\n\u003e I don't recommend you add this complexity to your application code, but this could be useful if you maintain a library.\r\n\r\n```jsx\r\ntype Validate\u003c\r\n  Arg,\r\n  ExpectedType,\r\n  ErrorMsg extends string\r\n\u003e = Arg extends ExpectedType ? Arg : ErrorMsg;\r\n\r\nfunction sendMessage\u003cArg\u003e(\r\n  message: Validate\u003cArg, string, \"The message must be of type 'string'\"\u003e\r\n) {}\r\n\r\n// This won't compile!\r\n// Validate will return the specific type literal:\r\n//  \"The message must be of type 'string'\"\r\nsendMessage(1);\r\n\r\n// compiles without issues:\r\nsendMessage(\"hello\");\r\n```\r\n\r\n## Renaming Fields of an Object\r\n\r\nLet's say you want to create a new object, whose keys are the same as another object, but _in uppercase_.\r\nYou can use the `as` keyword when iterating over fields using `in`, to rename the existing fields:\r\n\r\n```jsx\r\nconst some_constants = {\r\n  max_age: 100,\r\n  minimum_age: 0,\r\n  country_of_residence: \"AU\"\r\n};\r\n\r\ntype SomeConstantsInUppercase = {\r\n  [Property in keyof typeof some_constants as Uppercase\u003cProperty\u003e]: typeof some_constants[Property];\r\n}\r\n\r\n// results in:\r\n{\r\n  MAX_AGE: 100,\r\n  MINIMUM_AGE: 0,\r\n  COUNTRY_OF_RESIDENCE: \"AU\"\r\n}\r\n```\r\n\r\nNote: `Uppercase` is another inbuilt TypeScript utility.\r\n\r\n## Using `infer`\r\n\r\n`infer` is something I confess to not understand very well. However I have found it useful when creating more complex types\r\nand I find looking at some examples helpful in understanding how to use it.\r\n\r\n`infer` is used with conditional types in order to extract types in the condition and assign it to another generic variable.\r\nThe golden rule to remember when using `infer` is:\r\n\r\n\u003e `infer` can only be used in the `extends` clause of a _conditional_ type.\r\n\r\nHere's an example where I convert a string from `kebab-case` to `snake_case`:\r\n\r\n```jsx\r\ntype KebabToSnakeCase\u003cS extends string\u003e = S extends `${infer Char}${infer Rest}`\r\n  ? Char extends \"-\"\r\n    ? `_${KebabToSnakeCase\u003cRest\u003e}`\r\n    : `${Char}${KebabToSnakeCase\u003cRest\u003e}`\r\n  : S;\r\n\r\ntype Result = KebabToSnakeCase\u003c\"convert-this-kebab-case-to-snake-case\"\u003e;\r\n\r\n// Gives: \"convert_this_kebab_case_to_snake_case\"\r\n```\r\n\r\nWhat the following line:\r\n\r\n```jsx\r\nS extends `${infer Char}${infer Rest}`\r\n```\r\n\r\ndoes is that it checks if the generic `S` is a string that is of the template `${Char}${Rest}` - `Char` and `Rest` are named\r\ngeneric variables, and TypeScript will figure out what they are. If the string _does conform_ to it, `Char` will be the\r\nfirst character of a string, while `Rest` will be the remaining characters in the string.\r\n\r\nHere's another example where I extract the value from an object, given the dot-separated path - just like in Lodash's `get` utility:\r\n\r\n```jsx\r\ntype ExtractTypeFromPath\u003c\r\n  Path extends string,\r\n  Object extends Record\u003cstring, any\u003e\r\n\u003e = Path extends `${infer Property}.${infer RestOfPath}`\r\n  ? ExtractTypeFromPath\u003cRestOfPath, Object[Property]\u003e\r\n  : Object[Path];\r\n\r\ninterface Person {\r\n  data: {\r\n    firstName: string;\r\n    lastName: string;\r\n    sensitive: {\r\n      age: number;\r\n    };\r\n  };\r\n}\r\n// Results in number\r\ntype TypeOfAge = ExtractTypeFromPath\u003c\"data.sensitive.age\", Person\u003e;\r\n```\r\n\r\n## Dynamically inferring types from JavaScript\r\n\r\nIn the examples so far, we've been dealing exclusively with types - which have no\r\nimpact on the actual execution of our app - after all, the compiler just strips out\r\nall the type definitions.\r\n\r\nHowever, one of the most useful patterns I've found is to derive types from\r\nactual JavaScript objects. The trick is to use `as const` to\r\nensure that the most accurate types would be derived.\r\n\r\nFor example, if you were to do this:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"];\r\n```\r\n\r\n`typeof fieldNames` would give you `string[]`\r\n\r\nHowever, if we did this instead:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\n```\r\n\r\nThis would give you `(\"name\" | \"age\")[]` - which is far more useful. We can then extract the values in the array using:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\ntype FieldName = typeof fieldNames[number];\r\n\r\n// results in: FieldName = \"name\" | \"age\"\r\n```\r\n\r\nA very simplified example of how this can be useful, is when you want to specify in _JavaScript_ what fields a REST API endpoint\r\nshould return.\r\n\r\n```jsx\r\nconst fieldsToFetch = [\"first_name\", \"last_name\", \"dob\", \"country\"] as const;\r\n\r\nasync function someRestAPICall\u003cFields extends typeof fieldsToFetch\u003e(\r\n    fields: Fields\r\n): Promise\u003c{ [Property in Fields[number]]: string }\u003e {\r\n  // call endpoint and return JSON data\r\n}\r\n\r\nconst response = await someRestAPICall(fieldsToFetch);\r\n\r\n// The type of response would be:\r\n{\r\n  first_name: string;\r\n  last_name: string;\r\n  dob: string;\r\n  country: string;\r\n}\r\n```\r\n\r\nSo if you want to change which fields to request from the REST API, you just update `fieldsToFetch`, and the\r\nresponse would `automatically` update to the correct type.\r\n\r\nFor example, if you removed `\"last_name\"`, and somewhere in the application you referred to `response.last_name`, Typescript will fail to compile with an error!\r\n\r\n\u003e Update: As of Typescript 4.9, you can use the `satisfies` operator to enforce additional type safety when defining `as const` objects. Read this article for more info on `satisfies`: https://www.totaltypescript.com/clarifying-the-satisfies-operator\r\n"},"estimatedReadingTime":{"minutes":9,"words":1142,"text":"9 min read"},"headings":["Creating type safe utility functions","Conditional types","Renaming Fields of an Object","Using `infer`","Dynamically inferring types from JavaScript"]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"favourite-typescript"},"buildId":"OHDaK1tubpGiXm7rSbjcv","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>