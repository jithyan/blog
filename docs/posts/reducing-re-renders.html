<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Markdown."/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Optimizing React: Memoization and Reducing Re-renders</title><meta name="next-head-count" content="17"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/blog/_next/static/css/864e9443e5171e2f.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/864e9443e5171e2f.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/a7fa4402bacb9a02.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/a7fa4402bacb9a02.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-769ee50b99c88018.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ed62687b5581921b.js" defer=""></script><script src="/blog/_next/static/chunks/main-cb7b41c9cdc2a097.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f51201e12e7e4d94.js" defer=""></script><script src="/blog/_next/static/chunks/195-2bce04d007c0e362.js" defer=""></script><script src="/blog/_next/static/chunks/503-5f0d2c6f9d0a5f52.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-921e3e5e152507bd.js" defer=""></script><script src="/blog/_next/static/_TaFObsTst2XQnbmx62WG/_buildManifest.js" defer=""></script><script src="/blog/_next/static/_TaFObsTst2XQnbmx62WG/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Inter">@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZs.woff) format('woff')}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZJhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZthjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZNhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZxhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZBhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZFhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="bg-gray-900"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-lg md:text-xl font-bold underline text-teal-500 mb-20 pt-8"><a class="hover:text-sky-400" href="/blog">Home</a></h2><article class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-pink-500 font-bold text-center text-6xl tracking-tighter leading-tight mx-auto md:text-left">Optimizing React: Memoization and Reducing Re-renders</h1><div class="mt-2 mb-6 text-lg text-white font-semibold"><time dateTime="2022-07-31T20:00:00.000Z">August	1, 2022</time> | <span>Jithya Nanayakkara</span></div></div><div class="max-w-2xl mx-auto text-gray-300"><div class="markdown-styles_markdown__8Ahqd"><p>In my experience, React&#x27;s memoization functions have been a source of confusion for many developers - either being criminally overused in the name of &quot;performance&quot;, or woefully underutilized.</p>
<p>In this blog post, I&#x27;m going to attempt to dispel the uncertainty of when to use these functions, understand their trade-offs, and introduce you to ways of avoiding them altogether.</p>
<p>So what is <a href="https://en.wikipedia.org/wiki/Memoization">Memoization</a>? It&#x27;s a technique where the result of an expensive computation is cached to improve performance on subsequent calls to it. It&#x27;s a tradeoff that consumes more memory to save on execution time.</p>
<p>In React, its memoization functions are primarily used to:</p>
<ol>
<li>Avoid needless re-renders of a component (using <code class="bg-slate-800 px-2">React.memo</code>) or re-execution of expensive logic (<code class="bg-slate-800 px-2">useMemo</code>).</li>
<li>Provide a stable reference for objects (both <code class="bg-slate-800 px-2">useMemo</code> and <code class="bg-slate-800 px-2">useCallback</code>).</li>
</ol>
<p>Devs tend to focus on the first point - where some <a href="https://royi-codes.vercel.app/thousand-usecallbacks/">overuse those functions</a> in the name of &quot;performance&quot;. But point number 2 is an important use case for React&#x27;s functional components, especially when writing libraries, and is often overlooked.</p>
<p>To really understand in which circumstances we make use of them, I need to cover the basics of how React works - apologies to those who are already familiar with this, but it&#x27;s useful that everyone is on the same page with the terminology used here.</p>
<h2>An overview of React</h2>
<blockquote>
<p>For simplicity, I&#x27;m going to pretend React classes don&#x27;t exist.</p>
</blockquote>
<p>React provides us with a component based <a href="https://computersciencewiki.org/index.php/Abstraction">abstraction</a> for easily updating the DOM in response to state changes. This is done by representing the DOM with a <strong>Virtual DOM</strong> (V-DOM), that is nothing more than a lightweight representation of the actual DOM. In other words, it is just a collection of simple Javascript objects used to represent the actual DOM.</p>
<p>The idea behind this is that since updates to the actual DOM are expensive operations, we could instead make frequent updates to the V-DOM, and then figure out which of the actual DOM elements need to be updated by diffing the old and new state of the V-DOM. This process is called <a href="https://reactjs.org/docs/reconciliation.html">reconcilliation</a> and is fast but does not aim to be very accurate - just good enough to minimize unecessary DOM updates for most practical use cases.</p>
<p>With that out of the way, time for some terminology:</p>
<ul>
<li>A React <strong>Element</strong> is a simple Javascript object that represents a node in the V-DOM.</li>
<li>A React <strong>Component</strong> is a function that accepts some <em>props</em> and returns React Elements.</li>
</ul>
<p>This is what a React <strong>element</strong> looks like, and you can get this by just console logging the output of a component:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/react-elements-object.png" alt="Initial"/></p>
<ul>
<li>A <strong>render</strong> is when the React Component (i.e. the function) is executed.</li>
<li>A <strong>commit</strong> is when React actually updates a DOM element.</li>
</ul>
<p>Note the difference between <code class="bg-slate-800 px-2">render</code> and <code class="bg-slate-800 px-2">commit</code>. Many developers confuse the two, but they are <em>not</em> the same. When a component &quot;renders&quot;, it does not necessarily mean the DOM is going to be updated - React may have figured out that nothing has changed after a state update, and skip updating portions of the DOM.</p>
<p>To really drive home this point, <strong>React components can render many, many times</strong>. These are just basic functions being executed after all - and in most cases, they execute fast with minimal impact on performance. It&#x27;s objects like the one pictured above that get updated every render - based on how they change, React will decide which DOM elements to update.</p>
<h2>Understanding what happens in a render</h2>
<p>Here are some possible reasons a component would re-render (this list is not exhaustive):</p>
<ol>
<li>The component&#x27;s parent has re-rendered.</li>
<li>The component&#x27;s state changed (i.e. <code class="bg-slate-800 px-2">setState</code> was called).</li>
<li>The component is a subscriber to a React Context - every time the Context value changes, the component will re-render.</li>
</ol>
<p>Understanding why your component has re-rendered is a critical first step in diagnosing React performance problems.
So see if you can identify what would cause the example component below to re-render:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function Counter() {
  const [counter, setCounter] = useState(0);
  const user = useContext(UserContext);

  // A callback to increment the counter, passed to FancyButton
  const incrementer = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  };

  // An object that is the prop to FancyButton
  // I&#x27;m aware this is a little unusual, but there are situations where
  // you pass in complex objects as props to a component.
  const buttonConfig = {
    name: &quot;hello&quot;,
    display: counter,
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;My Special Counter&lt;/h3&gt;
      &lt;p&gt;Hello, {user}!&lt;/p&gt;
      &lt;FancyButton config={buttonConfig} onClick={incrementer} /&gt;
    &lt;/div&gt;
  );
}</code></div></pre>
<p>The following are triggers that would cause <code class="bg-slate-800 px-2">Counter</code> to re-render:</p>
<ol>
<li>The <em>parent</em> of <code class="bg-slate-800 px-2">Counter</code> is re-rendered.</li>
<li><code class="bg-slate-800 px-2">setCounter</code> is called via the <code class="bg-slate-800 px-2">incrementer</code> callback (and it&#x27;s called with a <em>different</em> value - React has an optimization where if the new value to <code class="bg-slate-800 px-2">setState</code> is the same as the old, a re-render will not happen).</li>
<li>The object returned by <code class="bg-slate-800 px-2">useContext</code> has changed.</li>
</ol>
<p>Every time one of the above triggers are set off, React will execute the <code class="bg-slate-800 px-2">Counter</code> function again, and return the child elements.
These child elements, written as JSX, are nothing more than functions too - they are compiled into <code class="bg-slate-800 px-2">React.createElement(args)</code> function calls.
The reason why we use JSX is that it provides a nice familiar <a href="https://en.wikipedia.org/wiki/Declarative_programming">declarative</a> abstraction like HTML to write components - just imagine writing a page as a bunch of nested function calls!</p>
<p>Below is an example of what React code (pre-v17.0) would transform to (taken from the <a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx">Babel React Transform Plugin docs</a>):</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const profile = React.createElement(
  &quot;div&quot;,
  null,
  React.createElement(&quot;img&quot;, { src: &quot;avatar.png&quot;, className: &quot;profile&quot; }),
  React.createElement(&quot;h3&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;))
);</code></div></pre>
<p>So continuing with our example, with each re-render of <code class="bg-slate-800 px-2">Counter</code>, the following will happen:</p>
<ol>
<li><code class="bg-slate-800 px-2">incrementer</code> will be assigned to a <em>new</em> callback <strong>object</strong>. Remember functions in Javascript are objects too!</li>
<li><code class="bg-slate-800 px-2">buttonConfig</code> will also be assigned to a new object. Remember that <code class="bg-slate-800 px-2">{} !== {}</code>. So both <code class="bg-slate-800 px-2">incrementer</code> and <code class="bg-slate-800 px-2">buttonConfig</code> will be assigned to <strong>new references</strong> in memory on <em>every render</em>.</li>
<li>All the React Elements returned from <code class="bg-slate-800 px-2">Counter</code> will be <em>recreated</em>.</li>
</ol>
<p>Now let&#x27;s discuss performance. Given what we know from above, would repeated renders of <code class="bg-slate-800 px-2">Counter</code> impact performance by constantly re-allocating memory for variables and running all those functions again? Not really.</p>
<p>These operations are quite cheap, and the Javascript runtime is optimized for doing these operations efficiently. But this could be a problem if you have an app with hundreds or thousands of components re-rendering frequently (and of course, it depends on the user&#x27;s hardware).</p>
<p>So do we wrap everything we can with <code class="bg-slate-800 px-2">memo</code>, <code class="bg-slate-800 px-2">useMemo</code> and <code class="bg-slate-800 px-2">useCallback</code>? Some people do, which is probably why you see a lot of blog posts saying to avoid abusing React&#x27;s memo functions for optimizing performance - it&#x27;s because the act of memoization trades off time for space. We cache prior values and return them instead of executing functions again.</p>
<p>But there&#x27;s a small cost with this. And the cost could be significant if we end up not using the cached values much, and end up frequently caching a value, throwing it away because it&#x27;s stale, and then creating a new one.</p>
<p><strong>Since it&#x27;s easy to shoot yourself in the foot and use these incorrectly, premature optimization should be avoided.</strong></p>
<p>However as long as you understand how React works, choosing when to use the memoization functions is pretty straightforward. And in my experience, you don&#x27;t need to use them too often.</p>
<p>Now that we&#x27;ve covered why a component can re-render, and how variables are given new references on each render, we can dive into optimization.
To do that, we need to work through a much more meaty example. This example is incredibly silly and quite long, but we need it to be a few components deep so we could systematically walk through how it could be optimized.</p>
<h3>A Random Number List Generator and Counter Example</h3>
<p>This is what our example app looks like:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/app-first-load.png" alt="Picture of example app"/></p>
<p>And it does the following:</p>
<ul>
<li>Displays a list of random numbers.</li>
<li>Each random number is styled either with a black or white background. How this is decided is by generating <em>another</em> random number, and checking if it&#x27;s even or odd.</li>
<li>We also give the user a button to click, which increments a counter.</li>
</ul>
<p>Below is the code for the above app (I&#x27;ve stripped out any CSS, for simplicity):</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">ReactDOM.render(&lt;App /&gt;, rootElement);

// The Parent component - note that it has no state
// and passes a fixed prop to RandomNumberListAndCounter
function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;RandomNumberListAndCounter length={10} /&gt;
    &lt;/div&gt;
  );
}

function RandomNumberListAndCounter({ length }) {
  const [counter, setCounter] = useState(0);
  // We keep the random number list in state, so that we can control
  // when the list of random numbers is updated, independent of re-renders of the component.
  const [randomNumbers, setRandomNumbers] = useState(
    generateListOfRandomNumbers(length)
  );

  // Generate a different set of random numbers every time length changes
  useEffect(() =&gt; {
    setRandomNumbers(generateListOfRandomNumbers(length));
  }, [length]);

  const incrementOnClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  };

  // An object that is the prop to ButtonWithFooter
  // A little unusual, but sometimes you may need to pass
  // complex objects to a component
  const configProp = {
    name: &quot;Special counter incrementer&quot;,
    listLength: length,
  };

  return (
    &lt;div&gt;
      {/* Displays the counter */}
      &lt;FancyHeader counter={counter} /&gt;
      {/* Displays the styled list of random numbers */}
      &lt;FancyNumberListFormatter numberList={randomNumbers} /&gt;
      {/* Increments the counter, and shows how many random numbers are shown*/}
      &lt;ButtonWithFooter config={configProp} onClick={incrementOnClick} /&gt;
    &lt;/div&gt;
  );
}

function FancyHeader({ counter }) {
  return (
    &lt;hgroup&gt;
      &lt;h1&gt;My Special Counter&lt;/h1&gt;
      &lt;h2&gt;Clicked {counter} times.&lt;/h2&gt;
    &lt;/hgroup&gt;
  );
}

function FancyNumberListFormatter({ numberList }) {
  return (
    &lt;div&gt;
      {numberList.map((number, i) =&gt; (
        &lt;RandomlyStyledNumber number={number} key={`${number}-${i}`} /&gt;
      ))}
    &lt;/div&gt;
  );
}

function RandomlyStyledNumber({ number }) {
  const [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);

  // I&#x27;m skipping showing any styling
  const evenStyle = {};
  const oddStyle = {};

  return &lt;span style={isEven ? evenStyle : oddStyle}&gt;{number}&lt;/span&gt;;
}

function ButtonWithFooter({ config, onClick }) {
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;button onClick={onClick}&gt;{config.name}&lt;/button&gt;
      &lt;/div&gt;
      {/* 
        Normally you wouldn&#x27;t include a footer with a button, but this is only
        for the purpose of the example 
      */}
      &lt;footer&gt;
        &lt;em&gt;Number of random numbers shown: {config.listLength}&lt;/em&gt;
      &lt;/footer&gt;
    &lt;/&gt;
  );
}</code></div></pre>
<p>The functions to generate the random numbers use the browser <code class="bg-slate-800 px-2">crypto</code> library.
I&#x27;ve written it in a way so that it&#x27;s <strong>really</strong> slow.</p>
<p>It is <strong>not important</strong> to understand how they work, I&#x27;m just including it if you&#x27;re curious:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-typescript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function getExpensiveRandomNumber() {
  return new Array(1000)
    .fill(null)
    .map(
      () =&gt; Array.from(window.crypto.getRandomValues(new Uint16Array(1000)))[0]
    )[0];
}

function generateListOfRandomNumbers(length) {
  return new Array(length).fill(null).map(getExpensiveRandomNumber);
}</code></div></pre>
<p>This is the hierarchy of the components:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/component-hierarchy.png" alt="Component Hierarchy"/></p>
<p>So how does this app perform?
To answer this question, I&#x27;m going to use the React DevTools Profiler to measure how long it takes to render all the components:</p>
<ul>
<li>I just want the <code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> to re-render, so I can do this by clicking on the
increment counter button.</li>
<li>Before clicking the counter button, I hit record on the profiler, then after I see the counter increment, I stop recording.</li>
<li>If any renders took place, the profile will spit out a flame graph of how long each component took to render.</li>
</ul>
<p><img src="/blog/assets/blog/reducing-re-renders/app-first-click.png" alt="First click"/></p>
<p><img src="/blog/assets/blog/reducing-re-renders/app-first-click-profiler.png" alt="First click profiler"/></p>
<p>A few observations about the profiler:</p>
<ol>
<li>We can see the total time it took to render <code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> and all its children was a whopping <strong>1.25 seconds</strong>!</li>
<li><code class="bg-slate-800 px-2">App</code> did not re-render (we can tell because of its gray color).</li>
<li>Even though only the text &quot;Clicked 1 times&quot; is what changed, all the child components of <code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> <em>re-rendered</em>.</li>
</ol>
<h2>Optimizing the Example</h2>
<p>We desperately need to fix the slow re-rendering of the example every time we increment the counter. And we can actually do this without memoization, by using <code class="bg-slate-800 px-2">useState</code>&#x27;s <strong>initialization function</strong>.</p>
<p>Currently, every time we render the component, we&#x27;re generating and throwing away the random number list.
By passing an initialization function to <code class="bg-slate-800 px-2">useState</code>, React will only invoke the function once (on the component&#x27;s first render).</p>
<p>This is the existing problem code:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">// In RandomNumberListAndCounter:
const [randomNumbers, setRandomNumbers] = useState(
  generateListOfRandomNumbers(length)
);

// In RandomStyledNumber:
const [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);</code></div></pre>
<p>And this is the fixed code:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">// In RandomNumberListAndCounter:
const [randomNumbers, setRandomNumbers] = useState(() =&gt;
  generateListOfRandomNumbers(length)
);

// In RandomStyledNumber:
const [isEven] = useState(() =&gt; getExpensiveRandomNumber() % 2 === 0);</code></div></pre>
<blockquote>
<p>Note that when we first load the App, its initial render will still be painfully slow. But at least we can tackle slow re-renders easily.</p>
</blockquote>
<p>Let&#x27;s see how this improves the profiler result:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/profiler-init-state.png" alt="Initialize state only once"/></p>
<p>0.9ms - A dramatic improvement!</p>
<blockquote>
<p>At this point, you&#x27;d normally stop optimizing your app (unless you expect it to grow in complexity). A 0.9ms re-render time is plenty fast. However, for the sake of learning, we&#x27;re going to optimize the rest of the app.</p>
</blockquote>
<p>But notice how all the <code class="bg-slate-800 px-2">RandomlyStyledNumber</code>, <code class="bg-slate-800 px-2">ButtonWithFooter</code> and <code class="bg-slate-800 px-2">FancyNumberListFormatter</code> components continue to re-render. These renders are unnecessary given the only thing that changes is the unrelated counter text.</p>
<p>This where <code class="bg-slate-800 px-2">React.memo</code> comes in. If we pass a component into <code class="bg-slate-800 px-2">React.memo</code>, it will only re-render it if its props have changed between re-renders of its parent. Parent components can re-render all they like, but as long as the props passed to the memoized component remain the same, the cached React Elements will be what&#x27;s returned.</p>
<p>This is how we call <code class="bg-slate-800 px-2">React.memo</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const MyComponentMemoized = React.memo(MyComponent);

// and use it like a regular component in JSX:
&lt;MyComponentMemoized /&gt;;</code></div></pre>
<p>So should we wrap all our components in the example with <code class="bg-slate-800 px-2">React.memo</code>?</p>
<p>No. It&#x27;s neither necessary nor optimal.</p>
<p>If look at the component hierarchy diagram again, we can see that the memoizing the following components is redundant:</p>
<ul>
<li><code class="bg-slate-800 px-2">App</code>: This is the root component. It&#x27;s pointless memoizing this as it has no parent component to trigger any re-renders.</li>
<li><code class="bg-slate-800 px-2">RandomNumberListAndCounter</code>: In the context of our example, this component will only re-render when its state, <code class="bg-slate-800 px-2">counter</code>, changes. Its parent component, <code class="bg-slate-800 px-2">App</code>, doesn&#x27;t also have any state so it would never re-render. Therefore wrapping it with <code class="bg-slate-800 px-2">React.memo</code> is redundant, as memoized components will continue to re-render when its internal state changes (which is what we want).</li>
<li><code class="bg-slate-800 px-2">RandomlyStyledNumber</code>: This component will <strong>only</strong> re-render when its parent, <code class="bg-slate-800 px-2">FancyNumberListFormatter</code>, re-renders. Therefore, only memoizing its parent is sufficient.</li>
<li><code class="bg-slate-800 px-2">FancyHeader</code>: This component depends on <code class="bg-slate-800 px-2">counter</code>, as its passed as a prop. We know that the only thing in our app that triggers a re-render is the <code class="bg-slate-800 px-2">counter</code> being updated. Therefore, wrapping this in <code class="bg-slate-800 px-2">React.memo</code> is redundant.</li>
</ul>
<p>So only these 2 components would benefit from memo:</p>
<ol>
<li><code class="bg-slate-800 px-2">FancyNumberListFormatter</code></li>
<li><code class="bg-slate-800 px-2">ButtonWithFooter</code></li>
</ol>
<p>Both of the above components depend on the <code class="bg-slate-800 px-2">length</code> prop, and not <code class="bg-slate-800 px-2">counter</code>. When <code class="bg-slate-800 px-2">counter</code> changes, these components end up re-rendering, so they&#x27;re good candidates for memoization.</p>
<p>Let&#x27;s go ahead and do just that:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const FancyNumberListFormatterMemoized = React.memo(FancyNumberListFormatter);
const ButtonWithFooterMemoized = React.memo(ButtonWithFooter);

function RandomNumberListAndCounter({ length }: { length: number }) {
  const [counter, setCounter] = useState(0);
  const [randomNumbers, setRandomNumbers] = useState(() =&gt;
    generateListOfRandomNumbers(length)
  );

  useEffect(() =&gt; {
    setRandomNumbers(generateListOfRandomNumbers(length));
  }, [length]);

  const incrementOnClick = () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  };

  const configProp = {
    name: &quot;Special counter incrementer&quot;,
    listLength: length,
  };

  return (
    &lt;div&gt;
      &lt;FancyHeader counter={counter} /&gt;
      &lt;FancyNumberListFormatterMemoized numberList={randomNumbers} /&gt;
      &lt;ButtonWithFooterMemoized
        config={configProp}
        onClick={incrementOnClick}
      /&gt;
    &lt;/div&gt;
  );
}</code></div></pre>
<p>Before we check the profiler, I&#x27;m going to throttle my CPU speed by 6x in Chrome - so that it simulates users who don&#x27;t have a developer grade laptop:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/throttle-cpu.png" alt="How to throttle CPU"/></p>
<p>And now let&#x27;s take a look at the React profiler, where I measure what happens after I click the counter button:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/memo-flamegraph.png" alt="Flamegraph of memoized components"/></p>
<p>Looking good - all components that don&#x27;t need to re-render aren&#x27;t rendering according to this flamegraph (indicated by the grayed out bars).</p>
<p>But the flamegraph isn&#x27;t showing all the re-rendering components, so let&#x27;s switch views to &quot;Ranking&quot;:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/memo-ranked.png" alt="Ranking of memoized components"/></p>
<p>Only two components should re-render: <code class="bg-slate-800 px-2">RandomNumberListFormatter</code> and <code class="bg-slate-800 px-2">FancyHeader</code>. <code class="bg-slate-800 px-2">RandomNumberListFormatter</code> contains the state <code class="bg-slate-800 px-2">counter</code>, which changes, and <code class="bg-slate-800 px-2">FancyHeader</code> takes in the prop <code class="bg-slate-800 px-2">counter</code>.</p>
<p>But it also looks like <code class="bg-slate-800 px-2">ButtonWithFooter</code> is re-rendering, even though it doesn&#x27;t care about the <code class="bg-slate-800 px-2">counter</code> value.</p>
<p>So why would <code class="bg-slate-800 px-2">ButtonWithFooter</code> re-render despite being memoized and having no props change?</p>
<p>Allow me to yank out the cause of this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">// New object assignment
const incrementOnClick = () =&gt; {
  setCounter((prev) =&gt; prev + 1);
};

// New object assignment
const configProp = {
  name: &quot;Special counter incrementer&quot;,
  listLength: length,
};

// Even though semantically the same, config and incrementOnClick
// are different objects on each render
&lt;ButtonWithFooterMemoized config={configProp} onClick={incrementOnClick} /&gt;;</code></div></pre>
<p>The thing to note is that when <code class="bg-slate-800 px-2">React.memo</code> compares the previous props with the new props, it uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a> to compare
if they&#x27;ve changed. This is a shallow comparison - so two objects that have the same values but different memory references,
are not equal (remember <code class="bg-slate-800 px-2">{} === {}</code> evaluates to <code class="bg-slate-800 px-2">false</code>).</p>
<p>And in our example, we&#x27;re creating <strong>new objects</strong> for <code class="bg-slate-800 px-2">incrementOnClick</code> and <code class="bg-slate-800 px-2">configProp</code> on <em>every render</em>.</p>
<p>We can easily fix this by using <code class="bg-slate-800 px-2">useMemo</code>, to cache the objects:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const incrementOnClick = useMemo(
  () =&gt; () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  },
  []
);

/**
 * We only create a new object when the `length` changes.
 */
const configProp = useMemo(
  () =&gt; ({
    name: &quot;Special counter incrementer&quot;,
    listLength: length,
  }),
  [length]
);</code></div></pre>
<p>And the new Ranked profiler result is:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/profiler-usememo.png" alt="Profiler after useMemo"/></p>
<p>Now only the two expected components re-render.</p>
<p>But... notice the awkward syntax for the incrementer. Since <code class="bg-slate-800 px-2">useMemo</code> accepts a function, and caches the return value of that function,
we need to pass in a function that returns a function.
Instead, we can use <code class="bg-slate-800 px-2">useCallback</code> instead of <code class="bg-slate-800 px-2">useMemo</code> - its explicit purpose is to cache callbacks (aka functions):</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const incrementer = useCallback(() =&gt; {
  setCounter((prev) =&gt; prev + 1);
}, []);</code></div></pre>
<h2>But we can do better</h2>
<p>As I said very early in this piece, there&#x27;s a small cost with memoizing. It <em>could</em> add up if we have tonnes of components being memoized.
But let&#x27;s see how we could re-write our memoized component in a way to minimize calls to memo.</p>
<h3>Using useRef to replace useCallback or useMemo</h3>
<p>In our example, we can see we&#x27;re calling <code class="bg-slate-800 px-2">useCallback</code> with an empty dependency array:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const [counter, setCounter] = useState(0);

const incrementOnClick = useCallback(() =&gt; {
  setCounter((prev) =&gt; prev + 1);
}, []);</code></div></pre>
<p>We can do this because <code class="bg-slate-800 px-2">React</code> guarantees <code class="bg-slate-800 px-2">setCounter</code> to be stable.</p>
<p>For scenarios where we have an empty dependency array for <code class="bg-slate-800 px-2">useCallback</code> or <code class="bg-slate-800 px-2">useMemo</code>, we could just store the variable in a ref instead.
Note that this only applies for <code class="bg-slate-800 px-2">useMemo</code> where you&#x27;re using it for a stable reference, and <strong>not</strong> to reduce expensive computations.</p>
<p>So our example can be re-written as follows:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const incrementOnClick = useRef(() =&gt; {
  setCounter((prev) =&gt; prev + 1);
});

&lt;ButtonWithFooterMemoized
  config={configProp}
  onClick={incrementOnClick.current}
/&gt;;</code></div></pre>
<p><code class="bg-slate-800 px-2">useRef</code> returns a reference to a mutable object. Like in <code class="bg-slate-800 px-2">useState</code>, the initial value you pass is assigned
only once, no matter how many times the component re-renders. How <code class="bg-slate-800 px-2">useRef</code> works is beyond the scope of this post, but you can <a href="https://beta.reactjs.org/apis/react/useRef">read more on it here</a>.</p>
<p>This technique is common in React libraries where returning stable references from hooks is important.</p>
<p>Since <code class="bg-slate-800 px-2">incrementOnClick.current</code> is a mutable object, its value will only change if we explicitly update it - so we don&#x27;t need to care about re-renders of the component re-assigning it to a different value.</p>
<p>The only thing to watch out for, is that since it&#x27;s a mutating object, React has no idea if it has changed - which is fine.
Usually we only want React to know if a variable has changed when we synchronize with effects or display the data - that&#x27;s why we use
hooks like <code class="bg-slate-800 px-2">useState</code>.</p>
<h3>Defining variables outside a component</h3>
<p>Not everything needs to go into <code class="bg-slate-800 px-2">useState</code>, or needs to be defined in a component. Too often, I find code like this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function Component() {
  const doABunchOfStuff = () =&gt; {
    const result = 1 + 1;
    console.log(&quot;result&quot;, result);
  };
  const config = { title: &quot;Beautiful example&quot;, theme: &quot;skyblue&quot; };

  return &lt;SomeotherComponent work={doABunchOfStuff} config={config} /&gt;;
}</code></div></pre>
<p>The key point of the above code is that <code class="bg-slate-800 px-2">doABunchOfStuff</code> and <code class="bg-slate-800 px-2">config</code> isn&#x27;t <em>referencing</em> any data defined <strong>in the component</strong>.</p>
<p>It does not need to tie itself to React&#x27;s rendering.</p>
<p>We can throw away concerns of stable references and garbage collection by just defining <code class="bg-slate-800 px-2">doABunchOfStuff</code> and <code class="bg-slate-800 px-2">config</code> outside of the component:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const doABunchOfStuff = () =&gt; {
  const a = 1 + 1;
  console.log(&quot;result&quot;, a);
};
const config = { title: &quot;Beautiful example&quot;, theme: &quot;skyblue&quot; };

function Component() {
  return &lt;SomeotherComponent work={doABunchOfStuff} config={config} /&gt;;
}</code></div></pre>
<h3>Pushing State Down</h3>
<p>There is one more technique I&#x27;d like to dive into, and it&#x27;s one where you can minimize having to use <code class="bg-slate-800 px-2">React.memo</code>. This technique involves restructuring your component tree hierarchy, so that state changes are localized to components that display them. Components that are meant to be rendered at the bottom of the tree, are passed down as <code class="bg-slate-800 px-2">children</code>.</p>
<p>It&#x27;s best understood by re-writing our example.</p>
<p>First, let&#x27;s put all the code related to the <code class="bg-slate-800 px-2">counter</code> in one component, called <code class="bg-slate-800 px-2">FancyCounter</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const ButtonWithFooterMemoized = React.memo(ButtonWithFooter);

function FancyCounter({ length, children }) {
  const [counter, setCounter] = useState(0);

  const incrementOnClick = useRef(() =&gt; {
    setCounter((prev) =&gt; prev + 1);
  });

  const configProp = useMemo(
    () =&gt; ({
      name: &quot;Special counter incrementer&quot;,
      listLength: length,
    }),
    [length]
  );

  return (
    &lt;div&gt;
      &lt;FancyHeader counter={counter} /&gt;
      {children}
      &lt;ButtonWithFooterMemoized
        config={configProp}
        onClick={incrementOnClick.current}
      /&gt;
    &lt;/div&gt;
  );
}</code></div></pre>
<p>This is the key point: now, <code class="bg-slate-800 px-2">FancyCounter</code> will only re-render when <code class="bg-slate-800 px-2">setCounter</code> is called - when this happens, its <code class="bg-slate-800 px-2">children</code> prop
will be <strong>unchanged</strong>. <code class="bg-slate-800 px-2">children</code> consists of React Elements passed down from the parent - as the parent has <em>not re-rendered</em>, these
objects remain unchanged - and React is smart enough to know that these do not need to be re-rendered.</p>
<p>This is how the rest of the re-written components look like:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function RandomNumberListAndCounter({ length }: { length: number }) {
  const [randomNumbers, setRandomNumbers] = useState(() =&gt;
    generateListOfRandomNumbers(length)
  );

  useEffect(() =&gt; {
    setRandomNumbers(generateListOfRandomNumbers(length));
  }, [length]);

  return (
    &lt;FancyCounter length={length}&gt;
      &lt;FancyNumberListFormatter numberList={randomNumbers} /&gt;
    &lt;/FancyCounter&gt;
  );
}</code></div></pre>
<p>We pass in <code class="bg-slate-800 px-2">FancyNumberListFormatter</code> as the <code class="bg-slate-800 px-2">children</code> of <code class="bg-slate-800 px-2">FancyCounter</code>. <code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> will only re-render if its parent changes,
and in our app, this will never happen. So <code class="bg-slate-800 px-2">React.memo</code> for <code class="bg-slate-800 px-2">FancyNumberListFormatter</code> is no longer needed!</p>
<p>We can see the React Profiler gives the same results:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/pushed-state-flamegraph.png" alt="Push state down flamegraph"/></p>
<p><img src="/blog/assets/blog/reducing-re-renders/pushed-state-ranked.png" alt="Push state down flamegraph"/></p>
<p>This technique was lifted straight from Dan Abramov himself - and I highly recommend reading <a href="https://overreacted.io/before-you-memo/">his blog post on it</a>.</p>
<p>The basic idea is that the prop <code class="bg-slate-800 px-2">children</code>, is a reference to some React elements created by the parent.
If the child component has re-rendered, and the <code class="bg-slate-800 px-2">children</code> prop remains the same, React knows that <code class="bg-slate-800 px-2">children</code> doesn&#x27;t have to be rendered again.</p>
<h3>Wrap Up</h3>
<p>When we want to create stable references, we can:</p>
<ol>
<li>Define objects and functions outside of a component, if they don&#x27;t rely on variables defined in the component itself.</li>
<li>If they do depend on variables defined in the component, we can use <code class="bg-slate-800 px-2">useCallback</code> and <code class="bg-slate-800 px-2">useMemo</code>.</li>
<li>If they depend on variables defined in the component that are already stable, we can use <code class="bg-slate-800 px-2">useRef</code> instead.</li>
</ol>
<p>When we want to prevent redundant expensive computations on re-render, we can:</p>
<ol>
<li>Pass an initialization function to <code class="bg-slate-800 px-2">useState</code>, if the result of the computation needs to be part of the component state.</li>
<li>Use <code class="bg-slate-800 px-2">useMemo</code>.</li>
</ol>
<p>When we want to minimize redundant renders of a component, we can:</p>
<ol>
<li>Use <code class="bg-slate-800 px-2">React.memo</code> so that a component will only re-render if its props change.</li>
<li>Reorganize the component tree, so that state changes are localized to components who consume that state.</li>
</ol>
<p>In our final optimized example app, we have:</p>
<ul>
<li>One component wrapped with <code class="bg-slate-800 px-2">React.memo</code></li>
<li>One object wrapped with <code class="bg-slate-800 px-2">useMemo</code></li>
<li>One callback stored in <code class="bg-slate-800 px-2">useRef</code></li>
</ul>
<p>A more naive approach would have been memoizing every component, object and callback in the app.</p></div></div></article></div></main></div><footer class="bg-slate-800"><div style="display:table" class="mx-auto"><ul class="list-none flex flex-row text-lg text-teal-500 underline font-semibold p-2"><li class="mr-4 max-w-md"><a href="https://github.com/jithyan" class="hover:text-sky-400 ">Github</a></li><li class=""><a href="https://www.linkedin.com/in/jithyan/" class=" hover:text-sky-400 ">LinkedIn</a></li></ul></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Optimizing React: Memoization and Reducing Re-renders","date":"2022-07-31T20:00:00.000Z","slug":"reducing-re-renders","author":{"name":"Jithya Nanayakkara"},"content":"\nIn my experience, React's memoization functions have been a source of confusion for many developers - either being criminally overused in the name of \"performance\", or woefully underutilized.\n\nIn this blog post, I'm going to attempt to dispel the uncertainty of when to use these functions, understand their trade-offs, and introduce you to ways of avoiding them altogether.\n\nSo what is [Memoization](https://en.wikipedia.org/wiki/Memoization)? It's a technique where the result of an expensive computation is cached to improve performance on subsequent calls to it. It's a tradeoff that consumes more memory to save on execution time.\n\nIn React, its memoization functions are primarily used to:\n\n1. Avoid needless re-renders of a component (using `React.memo`) or re-execution of expensive logic (`useMemo`).\n2. Provide a stable reference for objects (both `useMemo` and `useCallback`).\n\nDevs tend to focus on the first point - where some [overuse those functions](https://royi-codes.vercel.app/thousand-usecallbacks/) in the name of \"performance\". But point number 2 is an important use case for React's functional components, especially when writing libraries, and is often overlooked.\n\nTo really understand in which circumstances we make use of them, I need to cover the basics of how React works - apologies to those who are already familiar with this, but it's useful that everyone is on the same page with the terminology used here.\n\n## An overview of React\n\n\u003e For simplicity, I'm going to pretend React classes don't exist.\n\nReact provides us with a component based [abstraction](https://computersciencewiki.org/index.php/Abstraction) for easily updating the DOM in response to state changes. This is done by representing the DOM with a **Virtual DOM** (V-DOM), that is nothing more than a lightweight representation of the actual DOM. In other words, it is just a collection of simple Javascript objects used to represent the actual DOM.\n\nThe idea behind this is that since updates to the actual DOM are expensive operations, we could instead make frequent updates to the V-DOM, and then figure out which of the actual DOM elements need to be updated by diffing the old and new state of the V-DOM. This process is called [reconcilliation](https://reactjs.org/docs/reconciliation.html) and is fast but does not aim to be very accurate - just good enough to minimize unecessary DOM updates for most practical use cases.\n\nWith that out of the way, time for some terminology:\n\n- A React **Element** is a simple Javascript object that represents a node in the V-DOM.\n- A React **Component** is a function that accepts some _props_ and returns React Elements.\n\nThis is what a React **element** looks like, and you can get this by just console logging the output of a component:\n\n![Initial](/blog/assets/blog/reducing-re-renders/react-elements-object.png)\n\n- A **render** is when the React Component (i.e. the function) is executed.\n- A **commit** is when React actually updates a DOM element.\n\nNote the difference between `render` and `commit`. Many developers confuse the two, but they are _not_ the same. When a component \"renders\", it does not necessarily mean the DOM is going to be updated - React may have figured out that nothing has changed after a state update, and skip updating portions of the DOM.\n\nTo really drive home this point, **React components can render many, many times**. These are just basic functions being executed after all - and in most cases, they execute fast with minimal impact on performance. It's objects like the one pictured above that get updated every render - based on how they change, React will decide which DOM elements to update.\n\n## Understanding what happens in a render\n\nHere are some possible reasons a component would re-render (this list is not exhaustive):\n\n1. The component's parent has re-rendered.\n2. The component's state changed (i.e. `setState` was called).\n3. The component is a subscriber to a React Context - every time the Context value changes, the component will re-render.\n\nUnderstanding why your component has re-rendered is a critical first step in diagnosing React performance problems.\nSo see if you can identify what would cause the example component below to re-render:\n\n```jsx\nfunction Counter() {\n  const [counter, setCounter] = useState(0);\n  const user = useContext(UserContext);\n\n  // A callback to increment the counter, passed to FancyButton\n  const incrementer = () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  };\n\n  // An object that is the prop to FancyButton\n  // I'm aware this is a little unusual, but there are situations where\n  // you pass in complex objects as props to a component.\n  const buttonConfig = {\n    name: \"hello\",\n    display: counter,\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003ch3\u003eMy Special Counter\u003c/h3\u003e\n      \u003cp\u003eHello, {user}!\u003c/p\u003e\n      \u003cFancyButton config={buttonConfig} onClick={incrementer} /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nThe following are triggers that would cause `Counter` to re-render:\n\n1. The _parent_ of `Counter` is re-rendered.\n2. `setCounter` is called via the `incrementer` callback (and it's called with a _different_ value - React has an optimization where if the new value to `setState` is the same as the old, a re-render will not happen).\n3. The object returned by `useContext` has changed.\n\nEvery time one of the above triggers are set off, React will execute the `Counter` function again, and return the child elements.\nThese child elements, written as JSX, are nothing more than functions too - they are compiled into `React.createElement(args)` function calls.\nThe reason why we use JSX is that it provides a nice familiar [declarative](https://en.wikipedia.org/wiki/Declarative_programming) abstraction like HTML to write components - just imagine writing a page as a bunch of nested function calls!\n\nBelow is an example of what React code (pre-v17.0) would transform to (taken from the [Babel React Transform Plugin docs](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx)):\n\n```javascript\nconst profile = React.createElement(\n  \"div\",\n  null,\n  React.createElement(\"img\", { src: \"avatar.png\", className: \"profile\" }),\n  React.createElement(\"h3\", null, [user.firstName, user.lastName].join(\" \"))\n);\n```\n\nSo continuing with our example, with each re-render of `Counter`, the following will happen:\n\n1. `incrementer` will be assigned to a _new_ callback **object**. Remember functions in Javascript are objects too!\n2. `buttonConfig` will also be assigned to a new object. Remember that `{} !== {}`. So both `incrementer` and `buttonConfig` will be assigned to **new references** in memory on _every render_.\n3. All the React Elements returned from `Counter` will be _recreated_.\n\nNow let's discuss performance. Given what we know from above, would repeated renders of `Counter` impact performance by constantly re-allocating memory for variables and running all those functions again? Not really.\n\nThese operations are quite cheap, and the Javascript runtime is optimized for doing these operations efficiently. But this could be a problem if you have an app with hundreds or thousands of components re-rendering frequently (and of course, it depends on the user's hardware).\n\nSo do we wrap everything we can with `memo`, `useMemo` and `useCallback`? Some people do, which is probably why you see a lot of blog posts saying to avoid abusing React's memo functions for optimizing performance - it's because the act of memoization trades off time for space. We cache prior values and return them instead of executing functions again.\n\nBut there's a small cost with this. And the cost could be significant if we end up not using the cached values much, and end up frequently caching a value, throwing it away because it's stale, and then creating a new one.\n\n**Since it's easy to shoot yourself in the foot and use these incorrectly, premature optimization should be avoided.**\n\nHowever as long as you understand how React works, choosing when to use the memoization functions is pretty straightforward. And in my experience, you don't need to use them too often.\n\nNow that we've covered why a component can re-render, and how variables are given new references on each render, we can dive into optimization.\nTo do that, we need to work through a much more meaty example. This example is incredibly silly and quite long, but we need it to be a few components deep so we could systematically walk through how it could be optimized.\n\n### A Random Number List Generator and Counter Example\n\nThis is what our example app looks like:\n\n![Picture of example app](/blog/assets/blog/reducing-re-renders/app-first-load.png)\n\nAnd it does the following:\n\n- Displays a list of random numbers.\n- Each random number is styled either with a black or white background. How this is decided is by generating _another_ random number, and checking if it's even or odd.\n- We also give the user a button to click, which increments a counter.\n\nBelow is the code for the above app (I've stripped out any CSS, for simplicity):\n\n```jsx\nReactDOM.render(\u003cApp /\u003e, rootElement);\n\n// The Parent component - note that it has no state\n// and passes a fixed prop to RandomNumberListAndCounter\nfunction App() {\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cRandomNumberListAndCounter length={10} /\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction RandomNumberListAndCounter({ length }) {\n  const [counter, setCounter] = useState(0);\n  // We keep the random number list in state, so that we can control\n  // when the list of random numbers is updated, independent of re-renders of the component.\n  const [randomNumbers, setRandomNumbers] = useState(\n    generateListOfRandomNumbers(length)\n  );\n\n  // Generate a different set of random numbers every time length changes\n  useEffect(() =\u003e {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  const incrementOnClick = () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  };\n\n  // An object that is the prop to ButtonWithFooter\n  // A little unusual, but sometimes you may need to pass\n  // complex objects to a component\n  const configProp = {\n    name: \"Special counter incrementer\",\n    listLength: length,\n  };\n\n  return (\n    \u003cdiv\u003e\n      {/* Displays the counter */}\n      \u003cFancyHeader counter={counter} /\u003e\n      {/* Displays the styled list of random numbers */}\n      \u003cFancyNumberListFormatter numberList={randomNumbers} /\u003e\n      {/* Increments the counter, and shows how many random numbers are shown*/}\n      \u003cButtonWithFooter config={configProp} onClick={incrementOnClick} /\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction FancyHeader({ counter }) {\n  return (\n    \u003chgroup\u003e\n      \u003ch1\u003eMy Special Counter\u003c/h1\u003e\n      \u003ch2\u003eClicked {counter} times.\u003c/h2\u003e\n    \u003c/hgroup\u003e\n  );\n}\n\nfunction FancyNumberListFormatter({ numberList }) {\n  return (\n    \u003cdiv\u003e\n      {numberList.map((number, i) =\u003e (\n        \u003cRandomlyStyledNumber number={number} key={`${number}-${i}`} /\u003e\n      ))}\n    \u003c/div\u003e\n  );\n}\n\nfunction RandomlyStyledNumber({ number }) {\n  const [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);\n\n  // I'm skipping showing any styling\n  const evenStyle = {};\n  const oddStyle = {};\n\n  return \u003cspan style={isEven ? evenStyle : oddStyle}\u003e{number}\u003c/span\u003e;\n}\n\nfunction ButtonWithFooter({ config, onClick }) {\n  return (\n    \u003c\u003e\n      \u003cdiv\u003e\n        \u003cbutton onClick={onClick}\u003e{config.name}\u003c/button\u003e\n      \u003c/div\u003e\n      {/* \n        Normally you wouldn't include a footer with a button, but this is only\n        for the purpose of the example \n      */}\n      \u003cfooter\u003e\n        \u003cem\u003eNumber of random numbers shown: {config.listLength}\u003c/em\u003e\n      \u003c/footer\u003e\n    \u003c/\u003e\n  );\n}\n```\n\nThe functions to generate the random numbers use the browser `crypto` library.\nI've written it in a way so that it's **really** slow.\n\nIt is **not important** to understand how they work, I'm just including it if you're curious:\n\n```typescript\nfunction getExpensiveRandomNumber() {\n  return new Array(1000)\n    .fill(null)\n    .map(\n      () =\u003e Array.from(window.crypto.getRandomValues(new Uint16Array(1000)))[0]\n    )[0];\n}\n\nfunction generateListOfRandomNumbers(length) {\n  return new Array(length).fill(null).map(getExpensiveRandomNumber);\n}\n```\n\nThis is the hierarchy of the components:\n\n![Component Hierarchy](/blog/assets/blog/reducing-re-renders/component-hierarchy.png)\n\nSo how does this app perform?\nTo answer this question, I'm going to use the React DevTools Profiler to measure how long it takes to render all the components:\n\n- I just want the `RandomNumberListAndCounter` to re-render, so I can do this by clicking on the\n  increment counter button.\n- Before clicking the counter button, I hit record on the profiler, then after I see the counter increment, I stop recording.\n- If any renders took place, the profile will spit out a flame graph of how long each component took to render.\n\n![First click](/blog/assets/blog/reducing-re-renders/app-first-click.png)\n\n![First click profiler](/blog/assets/blog/reducing-re-renders/app-first-click-profiler.png)\n\nA few observations about the profiler:\n\n1. We can see the total time it took to render `RandomNumberListAndCounter` and all its children was a whopping **1.25 seconds**!\n2. `App` did not re-render (we can tell because of its gray color).\n3. Even though only the text \"Clicked 1 times\" is what changed, all the child components of `RandomNumberListAndCounter` _re-rendered_.\n\n## Optimizing the Example\n\nWe desperately need to fix the slow re-rendering of the example every time we increment the counter. And we can actually do this without memoization, by using `useState`'s **initialization function**.\n\nCurrently, every time we render the component, we're generating and throwing away the random number list.\nBy passing an initialization function to `useState`, React will only invoke the function once (on the component's first render).\n\nThis is the existing problem code:\n\n```javascript\n// In RandomNumberListAndCounter:\nconst [randomNumbers, setRandomNumbers] = useState(\n  generateListOfRandomNumbers(length)\n);\n\n// In RandomStyledNumber:\nconst [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);\n```\n\nAnd this is the fixed code:\n\n```javascript\n// In RandomNumberListAndCounter:\nconst [randomNumbers, setRandomNumbers] = useState(() =\u003e\n  generateListOfRandomNumbers(length)\n);\n\n// In RandomStyledNumber:\nconst [isEven] = useState(() =\u003e getExpensiveRandomNumber() % 2 === 0);\n```\n\n\u003e Note that when we first load the App, its initial render will still be painfully slow. But at least we can tackle slow re-renders easily.\n\nLet's see how this improves the profiler result:\n\n![Initialize state only once](/blog/assets/blog/reducing-re-renders/profiler-init-state.png)\n\n0.9ms - A dramatic improvement!\n\n\u003e At this point, you'd normally stop optimizing your app (unless you expect it to grow in complexity). A 0.9ms re-render time is plenty fast. However, for the sake of learning, we're going to optimize the rest of the app.\n\nBut notice how all the `RandomlyStyledNumber`, `ButtonWithFooter` and `FancyNumberListFormatter` components continue to re-render. These renders are unnecessary given the only thing that changes is the unrelated counter text.\n\nThis where `React.memo` comes in. If we pass a component into `React.memo`, it will only re-render it if its props have changed between re-renders of its parent. Parent components can re-render all they like, but as long as the props passed to the memoized component remain the same, the cached React Elements will be what's returned.\n\nThis is how we call `React.memo`:\n\n```javascript\nconst MyComponentMemoized = React.memo(MyComponent);\n\n// and use it like a regular component in JSX:\n\u003cMyComponentMemoized /\u003e;\n```\n\nSo should we wrap all our components in the example with `React.memo`?\n\nNo. It's neither necessary nor optimal.\n\nIf look at the component hierarchy diagram again, we can see that the memoizing the following components is redundant:\n\n- `App`: This is the root component. It's pointless memoizing this as it has no parent component to trigger any re-renders.\n- `RandomNumberListAndCounter`: In the context of our example, this component will only re-render when its state, `counter`, changes. Its parent component, `App`, doesn't also have any state so it would never re-render. Therefore wrapping it with `React.memo` is redundant, as memoized components will continue to re-render when its internal state changes (which is what we want).\n- `RandomlyStyledNumber`: This component will **only** re-render when its parent, `FancyNumberListFormatter`, re-renders. Therefore, only memoizing its parent is sufficient.\n- `FancyHeader`: This component depends on `counter`, as its passed as a prop. We know that the only thing in our app that triggers a re-render is the `counter` being updated. Therefore, wrapping this in `React.memo` is redundant.\n\nSo only these 2 components would benefit from memo:\n\n1. `FancyNumberListFormatter`\n2. `ButtonWithFooter`\n\nBoth of the above components depend on the `length` prop, and not `counter`. When `counter` changes, these components end up re-rendering, so they're good candidates for memoization.\n\nLet's go ahead and do just that:\n\n```javascript\nconst FancyNumberListFormatterMemoized = React.memo(FancyNumberListFormatter);\nconst ButtonWithFooterMemoized = React.memo(ButtonWithFooter);\n\nfunction RandomNumberListAndCounter({ length }: { length: number }) {\n  const [counter, setCounter] = useState(0);\n  const [randomNumbers, setRandomNumbers] = useState(() =\u003e\n    generateListOfRandomNumbers(length)\n  );\n\n  useEffect(() =\u003e {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  const incrementOnClick = () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  };\n\n  const configProp = {\n    name: \"Special counter incrementer\",\n    listLength: length,\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cFancyHeader counter={counter} /\u003e\n      \u003cFancyNumberListFormatterMemoized numberList={randomNumbers} /\u003e\n      \u003cButtonWithFooterMemoized\n        config={configProp}\n        onClick={incrementOnClick}\n      /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nBefore we check the profiler, I'm going to throttle my CPU speed by 6x in Chrome - so that it simulates users who don't have a developer grade laptop:\n\n![How to throttle CPU](/blog/assets/blog/reducing-re-renders/throttle-cpu.png)\n\nAnd now let's take a look at the React profiler, where I measure what happens after I click the counter button:\n\n![Flamegraph of memoized components](/blog/assets/blog/reducing-re-renders/memo-flamegraph.png)\n\nLooking good - all components that don't need to re-render aren't rendering according to this flamegraph (indicated by the grayed out bars).\n\nBut the flamegraph isn't showing all the re-rendering components, so let's switch views to \"Ranking\":\n\n![Ranking of memoized components](/blog/assets/blog/reducing-re-renders/memo-ranked.png)\n\nOnly two components should re-render: `RandomNumberListFormatter` and `FancyHeader`. `RandomNumberListFormatter` contains the state `counter`, which changes, and `FancyHeader` takes in the prop `counter`.\n\nBut it also looks like `ButtonWithFooter` is re-rendering, even though it doesn't care about the `counter` value.\n\nSo why would `ButtonWithFooter` re-render despite being memoized and having no props change?\n\nAllow me to yank out the cause of this:\n\n```javascript\n// New object assignment\nconst incrementOnClick = () =\u003e {\n  setCounter((prev) =\u003e prev + 1);\n};\n\n// New object assignment\nconst configProp = {\n  name: \"Special counter incrementer\",\n  listLength: length,\n};\n\n// Even though semantically the same, config and incrementOnClick\n// are different objects on each render\n\u003cButtonWithFooterMemoized config={configProp} onClick={incrementOnClick} /\u003e;\n```\n\nThe thing to note is that when `React.memo` compares the previous props with the new props, it uses [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) to compare\nif they've changed. This is a shallow comparison - so two objects that have the same values but different memory references,\nare not equal (remember `{} === {}` evaluates to `false`).\n\nAnd in our example, we're creating **new objects** for `incrementOnClick` and `configProp` on _every render_.\n\nWe can easily fix this by using `useMemo`, to cache the objects:\n\n```jsx\nconst incrementOnClick = useMemo(\n  () =\u003e () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  },\n  []\n);\n\n/**\n * We only create a new object when the `length` changes.\n */\nconst configProp = useMemo(\n  () =\u003e ({\n    name: \"Special counter incrementer\",\n    listLength: length,\n  }),\n  [length]\n);\n```\n\nAnd the new Ranked profiler result is:\n\n![Profiler after useMemo](/blog/assets/blog/reducing-re-renders/profiler-usememo.png)\n\nNow only the two expected components re-render.\n\nBut... notice the awkward syntax for the incrementer. Since `useMemo` accepts a function, and caches the return value of that function,\nwe need to pass in a function that returns a function.\nInstead, we can use `useCallback` instead of `useMemo` - its explicit purpose is to cache callbacks (aka functions):\n\n```jsx\nconst incrementer = useCallback(() =\u003e {\n  setCounter((prev) =\u003e prev + 1);\n}, []);\n```\n\n## But we can do better\n\nAs I said very early in this piece, there's a small cost with memoizing. It _could_ add up if we have tonnes of components being memoized.\nBut let's see how we could re-write our memoized component in a way to minimize calls to memo.\n\n### Using useRef to replace useCallback or useMemo\n\nIn our example, we can see we're calling `useCallback` with an empty dependency array:\n\n```javascript\nconst [counter, setCounter] = useState(0);\n\nconst incrementOnClick = useCallback(() =\u003e {\n  setCounter((prev) =\u003e prev + 1);\n}, []);\n```\n\nWe can do this because `React` guarantees `setCounter` to be stable.\n\nFor scenarios where we have an empty dependency array for `useCallback` or `useMemo`, we could just store the variable in a ref instead.\nNote that this only applies for `useMemo` where you're using it for a stable reference, and **not** to reduce expensive computations.\n\nSo our example can be re-written as follows:\n\n```jsx\nconst incrementOnClick = useRef(() =\u003e {\n  setCounter((prev) =\u003e prev + 1);\n});\n\n\u003cButtonWithFooterMemoized\n  config={configProp}\n  onClick={incrementOnClick.current}\n/\u003e;\n```\n\n`useRef` returns a reference to a mutable object. Like in `useState`, the initial value you pass is assigned\nonly once, no matter how many times the component re-renders. How `useRef` works is beyond the scope of this post, but you can [read more on it here](https://beta.reactjs.org/apis/react/useRef).\n\nThis technique is common in React libraries where returning stable references from hooks is important.\n\nSince `incrementOnClick.current` is a mutable object, its value will only change if we explicitly update it - so we don't need to care about re-renders of the component re-assigning it to a different value.\n\nThe only thing to watch out for, is that since it's a mutating object, React has no idea if it has changed - which is fine.\nUsually we only want React to know if a variable has changed when we synchronize with effects or display the data - that's why we use\nhooks like `useState`.\n\n### Defining variables outside a component\n\nNot everything needs to go into `useState`, or needs to be defined in a component. Too often, I find code like this:\n\n```jsx\nfunction Component() {\n  const doABunchOfStuff = () =\u003e {\n    const result = 1 + 1;\n    console.log(\"result\", result);\n  };\n  const config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\n  return \u003cSomeotherComponent work={doABunchOfStuff} config={config} /\u003e;\n}\n```\n\nThe key point of the above code is that `doABunchOfStuff` and `config` isn't _referencing_ any data defined **in the component**.\n\nIt does not need to tie itself to React's rendering.\n\nWe can throw away concerns of stable references and garbage collection by just defining `doABunchOfStuff` and `config` outside of the component:\n\n```jsx\nconst doABunchOfStuff = () =\u003e {\n  const a = 1 + 1;\n  console.log(\"result\", a);\n};\nconst config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\nfunction Component() {\n  return \u003cSomeotherComponent work={doABunchOfStuff} config={config} /\u003e;\n}\n```\n\n### Pushing State Down\n\nThere is one more technique I'd like to dive into, and it's one where you can minimize having to use `React.memo`. This technique involves restructuring your component tree hierarchy, so that state changes are localized to components that display them. Components that are meant to be rendered at the bottom of the tree, are passed down as `children`.\n\nIt's best understood by re-writing our example.\n\nFirst, let's put all the code related to the `counter` in one component, called `FancyCounter`:\n\n```jsx\nconst ButtonWithFooterMemoized = React.memo(ButtonWithFooter);\n\nfunction FancyCounter({ length, children }) {\n  const [counter, setCounter] = useState(0);\n\n  const incrementOnClick = useRef(() =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  });\n\n  const configProp = useMemo(\n    () =\u003e ({\n      name: \"Special counter incrementer\",\n      listLength: length,\n    }),\n    [length]\n  );\n\n  return (\n    \u003cdiv\u003e\n      \u003cFancyHeader counter={counter} /\u003e\n      {children}\n      \u003cButtonWithFooterMemoized\n        config={configProp}\n        onClick={incrementOnClick.current}\n      /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nThis is the key point: now, `FancyCounter` will only re-render when `setCounter` is called - when this happens, its `children` prop\nwill be **unchanged**. `children` consists of React Elements passed down from the parent - as the parent has _not re-rendered_, these\nobjects remain unchanged - and React is smart enough to know that these do not need to be re-rendered.\n\nThis is how the rest of the re-written components look like:\n\n```jsx\nfunction RandomNumberListAndCounter({ length }: { length: number }) {\n  const [randomNumbers, setRandomNumbers] = useState(() =\u003e\n    generateListOfRandomNumbers(length)\n  );\n\n  useEffect(() =\u003e {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  return (\n    \u003cFancyCounter length={length}\u003e\n      \u003cFancyNumberListFormatter numberList={randomNumbers} /\u003e\n    \u003c/FancyCounter\u003e\n  );\n}\n```\n\nWe pass in `FancyNumberListFormatter` as the `children` of `FancyCounter`. `RandomNumberListAndCounter` will only re-render if its parent changes,\nand in our app, this will never happen. So `React.memo` for `FancyNumberListFormatter` is no longer needed!\n\nWe can see the React Profiler gives the same results:\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-flamegraph.png)\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-ranked.png)\n\nThis technique was lifted straight from Dan Abramov himself - and I highly recommend reading [his blog post on it](https://overreacted.io/before-you-memo/).\n\nThe basic idea is that the prop `children`, is a reference to some React elements created by the parent.\nIf the child component has re-rendered, and the `children` prop remains the same, React knows that `children` doesn't have to be rendered again.\n\n### Wrap Up\n\nWhen we want to create stable references, we can:\n\n1. Define objects and functions outside of a component, if they don't rely on variables defined in the component itself.\n2. If they do depend on variables defined in the component, we can use `useCallback` and `useMemo`.\n3. If they depend on variables defined in the component that are already stable, we can use `useRef` instead.\n\nWhen we want to prevent redundant expensive computations on re-render, we can:\n\n1. Pass an initialization function to `useState`, if the result of the computation needs to be part of the component state.\n2. Use `useMemo`.\n\nWhen we want to minimize redundant renders of a component, we can:\n\n1. Use `React.memo` so that a component will only re-render if its props change.\n2. Reorganize the component tree, so that state changes are localized to components who consume that state.\n\nIn our final optimized example app, we have:\n\n- One component wrapped with `React.memo`\n- One object wrapped with `useMemo`\n- One callback stored in `useRef`\n\nA more naive approach would have been memoizing every component, object and callback in the app.\n"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"reducing-re-renders"},"buildId":"_TaFObsTst2XQnbmx62WG","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>