<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A blog on web development with React and Typescript."/><title>Optimizing React: Part 3 - Avoiding Memoization</title><meta name="next-head-count" content="16"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/blog/_next/static/css/864e9443e5171e2f.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/864e9443e5171e2f.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/a7fa4402bacb9a02.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/a7fa4402bacb9a02.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-769ee50b99c88018.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ed62687b5581921b.js" defer=""></script><script src="/blog/_next/static/chunks/main-cb7b41c9cdc2a097.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-f51201e12e7e4d94.js" defer=""></script><script src="/blog/_next/static/chunks/299-6b06e3596b88e631.js" defer=""></script><script src="/blog/_next/static/chunks/503-5f0d2c6f9d0a5f52.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-db18f9fec0cab401.js" defer=""></script><script src="/blog/_next/static/sdgQCbCblRhJQea5TnrSF/_buildManifest.js" defer=""></script><script src="/blog/_next/static/sdgQCbCblRhJQea5TnrSF/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Inter">@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfMZs.woff) format('woff')}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZJhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZthjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZNhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+1F00-1FFF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZxhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0370-03FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZBhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZFhjp-Ek-_EeAmM.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Inter';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="bg-gray-900"><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-lg md:text-xl font-bold underline text-teal-500 mb-20 pt-8"><a class="hover:text-sky-400" href="/blog">Home</a></h2><article class="mb-32"><div class="max-w-2xl mx-auto"><h1 class="text-pink-500 font-bold text-center text-6xl tracking-tighter leading-tight mx-auto md:text-left">Optimizing React: Part 3 - Avoiding Memoization</h1><div class="mt-2 mb-6 text-lg text-white font-semibold"><time dateTime="2022-09-18T20:00:00.000Z">September	19, 2022</time> | <span>Jithya Nanayakkara</span> <!-- -->| <span>11 min read</span></div></div><div class="max-w-2xl mx-auto text-gray-300"><div class="markdown-styles_markdown__8Ahqd"><hr/>
<p>This is the final article in a series covering techniques for optimizing React&#x27;s performance by minimizing renders.</p>
<ol>
<li><a href="https://jithyan.github.io/blog/posts/understanding-renders">Part 1 - Understanding Renders</a></li>
<li><a href="https://jithyan.github.io/blog/posts/understanding-memoization">Part 2 - Understanding Memoization</a></li>
<li>Part 3 - Avoiding Memoization (this post)</li>
</ol>
<hr/>
<p>In the <a href="https://jithyan.github.io/blog/posts/understanding-memoization">last post</a>, we worked through an example application and used memoization to reduce unnecessary renders. However, as I said in the <a href="https://jithyan.github.io/blog/posts/understanding-renders">very first article</a> of this series, there&#x27;s a small cost with memoizing. And these costs <em>could</em> add up significantly if we have tonnes of components being memoized.</p>
<p>So let&#x27;s see how we could re-write our memoized example application from the <a href="https://jithyan.github.io/blog/posts/understanding-memoization">previous article</a> in a way that minimizes usage of memoization.</p>
<h3>Using useRef to replace useCallback or useMemo</h3>
<p>In our example from the <a href="https://jithyan.github.io/blog/posts/understanding-memoization">last post</a>, we can see we&#x27;re calling <code class="bg-slate-800 px-2">useCallback</code> with an <em>empty</em> dependency array:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-javascript" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const [counter, setCounter] = useState(0);

const incrementOnClick = useCallback(
  () =&gt; {
    setCounter((prev) =&gt; prev + 1);
  },
  // We don&#x27;t pass anything into the array, and the React linter
  // does not complain.
  []
);</code></div></pre>
<p>We can do this because <code class="bg-slate-800 px-2">React</code> guarantees <code class="bg-slate-800 px-2">setCounter</code> to be stable.</p>
<p>For scenarios where we have an empty dependency array for <code class="bg-slate-800 px-2">useCallback</code> or <code class="bg-slate-800 px-2">useMemo</code>, we could just store the variable in a ref instead.
Note that this only applies for <code class="bg-slate-800 px-2">useMemo</code> where you&#x27;re using it for a stable reference, and <strong>not</strong> to reduce expensive computations.</p>
<p>So our example can be re-written as follows:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const incrementOnClick = useRef(() =&gt; {
  setCounter((prev) =&gt; prev + 1);
});

&lt;ButtonWithFooterMemoized
  config={configProp}
  onClick={incrementOnClick.current}
/&gt;;</code></div></pre>
<p><code class="bg-slate-800 px-2">useRef</code> returns a reference to a <a href="https://blog.logrocket.com/immutability-in-react-ebe55253a1cc/">mutable object</a>. Like in <code class="bg-slate-800 px-2">useState</code>, the initial value you pass is assigned
only once, no matter how many times the component re-renders. How <code class="bg-slate-800 px-2">useRef</code> works is beyond the scope of this post, but you can <a href="https://beta.reactjs.org/apis/react/useRef">read more about it here</a>.</p>
<p>This technique is common in React libraries where returning stable references from hooks is important.</p>
<p>Since <code class="bg-slate-800 px-2">incrementOnClick.current</code> is a mutable object, its value will only change if we explicitly update it - so we don&#x27;t need to care about re-renders of the component re-assigning it to a different value.</p>
<p>The only thing to watch out for, is that since it&#x27;s a mutating object, React has no idea if it has changed - which is fine.
Usually we only want React to know if a variable has changed when we synchronize with effects or display the data - that&#x27;s why we use
hooks like <code class="bg-slate-800 px-2">useState</code>.</p>
<h3>Defining variables outside a component</h3>
<p>Not everything needs to go into <code class="bg-slate-800 px-2">useState</code>, or needs to be defined in a component. Too often, I find code like this:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function Component() {
  const doABunchOfStuff = () =&gt; {
    const result = 1 + 1;
    console.log(&quot;result&quot;, result);
  };
  const config = { title: &quot;Beautiful example&quot;, theme: &quot;skyblue&quot; };

  return &lt;SomeotherComponent work={doABunchOfStuff} config={config} /&gt;;
}</code></div></pre>
<p>The key point of the above code is that <code class="bg-slate-800 px-2">doABunchOfStuff</code> and <code class="bg-slate-800 px-2">config</code> isn&#x27;t <em>referencing</em> any data or functions defined <strong><em>in</em> the component</strong>.</p>
<p>Therefore, it does not need to tie itself to React&#x27;s rendering.</p>
<p>We can throw away concerns of stable references and garbage collection by just defining <code class="bg-slate-800 px-2">doABunchOfStuff</code> and <code class="bg-slate-800 px-2">config</code> outside of the component:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const doABunchOfStuff = () =&gt; {
  const a = 1 + 1;
  console.log(&quot;result&quot;, a);
};
const config = { title: &quot;Beautiful example&quot;, theme: &quot;skyblue&quot; };

function Component() {
  return &lt;SomeotherComponent work={doABunchOfStuff} config={config} /&gt;;
}</code></div></pre>
<h3>Pushing State Down</h3>
<p>There is one more technique I&#x27;d like to dive into, and it&#x27;s one where you can minimize having to use <code class="bg-slate-800 px-2">React.memo</code>. This technique involves restructuring your component tree hierarchy, so that state changes are localized to components that display them. Components that are meant to be rendered at the bottom of the tree, are passed down as <code class="bg-slate-800 px-2">children</code>.</p>
<p>It&#x27;s best understood by re-writing our example.</p>
<p>To refresh your memory, this the current component hierarchy of the example app:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/component-hierarchy.png" alt="Component Hierarchy"/></p>
<p>We are going to change the hierarchy so that less components need to re-rendered on a state change.</p>
<p>First, let&#x27;s put all the code related to the <code class="bg-slate-800 px-2">counter</code> state in one component, called <code class="bg-slate-800 px-2">FancyCounter</code>:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">const ButtonWithFooterMemoized = React.memo(ButtonWithFooter);

function FancyCounter({ length, children }) {
  const [counter, setCounter] = useState(0);

  const incrementOnClick = useRef(() =&gt; {
    setCounter((prev) =&gt; prev + 1);
  });

  const configProp = useMemo(
    () =&gt; ({
      name: &quot;Special counter incrementer&quot;,
      listLength: length,
    }),
    [length]
  );

  return (
    &lt;div&gt;
      {/**
    Note that we now will only render
    FancyHeader and ButtonWithFooterMemoized,
    but not FancyNumberListFormatter - we instead only include
    a reference to some children passed down by the
    parent component. 
    */}
      &lt;FancyHeader counter={counter} /&gt;
      {children}
      &lt;ButtonWithFooterMemoized
        config={configProp}
        onClick={incrementOnClick.current}
      /&gt;
    &lt;/div&gt;
  );
}</code></div></pre>
<p>This is the key point: now, <code class="bg-slate-800 px-2">FancyCounter</code> will only re-render when <code class="bg-slate-800 px-2">setCounter</code> is called - when this happens, its <code class="bg-slate-800 px-2">children</code> prop
will be <strong>unchanged</strong>. <code class="bg-slate-800 px-2">children</code> consists of React Elements passed down from the parent - as the parent has <em>not re-rendered</em>, these
objects remain unchanged - and React is smart enough to know that these do not need to be re-rendered.</p>
<p>This is how the rest of the re-written components look like:</p>
<pre><div style="color:#d4d4d4;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#1e1e1e"><code class="language-jsx" style="color:#9cdcfe;font-size:13px;text-shadow:none;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none">function RandomNumberListAndCounter({ length }: { length: number }) {
  const [randomNumbers, setRandomNumbers] = useState(() =&gt;
    generateListOfRandomNumbers(length)
  );

  useEffect(() =&gt; {
    setRandomNumbers(generateListOfRandomNumbers(length));
  }, [length]);

  return (
    &lt;FancyCounter length={length}&gt;
      {/** Note that this is no longer memoized! */}
      &lt;FancyNumberListFormatter numberList={randomNumbers} /&gt;
    &lt;/FancyCounter&gt;
  );
}</code></div></pre>
<p>We pass in <code class="bg-slate-800 px-2">FancyNumberListFormatter</code> as the <code class="bg-slate-800 px-2">children</code> of <code class="bg-slate-800 px-2">FancyCounter</code>.
<code class="bg-slate-800 px-2">RandomNumberListAndCounter</code> will only re-render if its parent changes,
and in our app, this will never happen. So <code class="bg-slate-800 px-2">React.memo</code> for <code class="bg-slate-800 px-2">FancyNumberListFormatter</code> is no longer needed!</p>
<p>This is what the new component hierarchy now looks like:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/push-state-down-hierarchy.png" alt="New Component Hierarchy"/></p>
<p>We can see that the React Profiler gives the same results:</p>
<p><img src="/blog/assets/blog/reducing-re-renders/pushed-state-flamegraph.png" alt="Push state down flamegraph"/></p>
<p><img src="/blog/assets/blog/reducing-re-renders/pushed-state-ranked.png" alt="Push state down flamegraph"/></p>
<p>This technique was lifted straight from Dan Abramov himself - and I highly recommend reading <a href="https://overreacted.io/before-you-memo/">his blog post on it</a>.</p>
<p>The basic idea is that the prop <code class="bg-slate-800 px-2">children</code>, is a reference to some React elements created by the parent.
If the child component has re-rendered, and the <code class="bg-slate-800 px-2">children</code> prop remains the same, React knows that <code class="bg-slate-800 px-2">children</code> doesn&#x27;t have to be rendered again.</p>
<h3>Wrap Up</h3>
<p>I do want to emphasize though, that the optimizations I&#x27;ve mentioned above <em>could</em> make your code a little harder to read.
In a lot of application code, readability and maintainability are higher concerns than performance. Libraries on the other hand need
to emphasize on having more performant code.</p>
<p>So ideally, you&#x27;d use these optimizations when you need to, and not simply for the sake of &quot;performance&quot;.</p>
<p>And now below, I will summarize everything we&#x27;ve learnt in this entire series.</p>
<p><strong>When we want to create stable references, we can:</strong></p>
<ol>
<li>Define objects and functions outside of a component, if they don&#x27;t rely on variables defined in the component itself.</li>
<li>If they do depend on variables defined in the component, we can use <code class="bg-slate-800 px-2">useCallback</code> and <code class="bg-slate-800 px-2">useMemo</code>.</li>
<li>If they depend on variables defined in the component that are already stable, we can use <code class="bg-slate-800 px-2">useRef</code> instead.</li>
</ol>
<p><strong>When we want to prevent redundant expensive computations on re-render, we can:</strong></p>
<ol>
<li>Pass an initialization function to <code class="bg-slate-800 px-2">useState</code> or <code class="bg-slate-800 px-2">useReducer</code>, if the result of the computation needs to be part of the component state.</li>
<li>Use <code class="bg-slate-800 px-2">useMemo</code>.</li>
</ol>
<p><strong>When we want to minimize redundant renders of a component, we can:</strong></p>
<ol>
<li>Use <code class="bg-slate-800 px-2">React.memo</code> so that a component will only re-render if its props change.</li>
<li>Reorganize the component tree, so that state changes are localized to components who consume that state.</li>
</ol>
<p>In our final optimized example app, we have:</p>
<ul>
<li>One component wrapped with <code class="bg-slate-800 px-2">React.memo</code></li>
<li>One object wrapped with <code class="bg-slate-800 px-2">useMemo</code></li>
<li>One callback stored in <code class="bg-slate-800 px-2">useRef</code></li>
</ul>
<p>A more naive approach would have been memoizing every component, object and callback in the app.</p></div></div></article></div></main></div><footer class="bg-slate-800"><div style="display:table" class="mx-auto"><ul class="list-none flex flex-row text-lg text-teal-500 underline font-semibold p-2"><li class="mr-4 max-w-md"><a href="https://github.com/jithyan" class="hover:text-sky-400 ">Github</a></li><li class=""><a href="https://www.linkedin.com/in/jithyan/" class=" hover:text-sky-400 ">LinkedIn</a></li></ul></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Optimizing React: Part 3 - Avoiding Memoization","date":"2022-09-18T20:00:00.000Z","slug":"avoiding-memoization","author":{"name":"Jithya Nanayakkara"},"content":"\n---\n\nThis is the final article in a series covering techniques for optimizing React's performance by minimizing renders.\n\n1. [Part 1 - Understanding Renders](https://jithyan.github.io/blog/posts/understanding-renders)\n2. [Part 2 - Understanding Memoization](https://jithyan.github.io/blog/posts/understanding-memoization)\n3. Part 3 - Avoiding Memoization (this post)\n\n---\n\nIn the [last post](https://jithyan.github.io/blog/posts/understanding-memoization), we worked through an example application and used memoization to reduce unnecessary renders. However, as I said in the [very first article](https://jithyan.github.io/blog/posts/understanding-renders) of this series, there's a small cost with memoizing. And these costs _could_ add up significantly if we have tonnes of components being memoized.\n\nSo let's see how we could re-write our memoized example application from the [previous article](https://jithyan.github.io/blog/posts/understanding-memoization) in a way that minimizes usage of memoization.\n\n### Using useRef to replace useCallback or useMemo\n\nIn our example from the [last post](https://jithyan.github.io/blog/posts/understanding-memoization), we can see we're calling `useCallback` with an _empty_ dependency array:\n\n```javascript\nconst [counter, setCounter] = useState(0);\n\nconst incrementOnClick = useCallback(\n  () =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  },\n  // We don't pass anything into the array, and the React linter\n  // does not complain.\n  []\n);\n```\n\nWe can do this because `React` guarantees `setCounter` to be stable.\n\nFor scenarios where we have an empty dependency array for `useCallback` or `useMemo`, we could just store the variable in a ref instead.\nNote that this only applies for `useMemo` where you're using it for a stable reference, and **not** to reduce expensive computations.\n\nSo our example can be re-written as follows:\n\n```jsx\nconst incrementOnClick = useRef(() =\u003e {\n  setCounter((prev) =\u003e prev + 1);\n});\n\n\u003cButtonWithFooterMemoized\n  config={configProp}\n  onClick={incrementOnClick.current}\n/\u003e;\n```\n\n`useRef` returns a reference to a [mutable object](https://blog.logrocket.com/immutability-in-react-ebe55253a1cc/). Like in `useState`, the initial value you pass is assigned\nonly once, no matter how many times the component re-renders. How `useRef` works is beyond the scope of this post, but you can [read more about it here](https://beta.reactjs.org/apis/react/useRef).\n\nThis technique is common in React libraries where returning stable references from hooks is important.\n\nSince `incrementOnClick.current` is a mutable object, its value will only change if we explicitly update it - so we don't need to care about re-renders of the component re-assigning it to a different value.\n\nThe only thing to watch out for, is that since it's a mutating object, React has no idea if it has changed - which is fine.\nUsually we only want React to know if a variable has changed when we synchronize with effects or display the data - that's why we use\nhooks like `useState`.\n\n### Defining variables outside a component\n\nNot everything needs to go into `useState`, or needs to be defined in a component. Too often, I find code like this:\n\n```jsx\nfunction Component() {\n  const doABunchOfStuff = () =\u003e {\n    const result = 1 + 1;\n    console.log(\"result\", result);\n  };\n  const config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\n  return \u003cSomeotherComponent work={doABunchOfStuff} config={config} /\u003e;\n}\n```\n\nThe key point of the above code is that `doABunchOfStuff` and `config` isn't _referencing_ any data or functions defined **_in_ the component**.\n\nTherefore, it does not need to tie itself to React's rendering.\n\nWe can throw away concerns of stable references and garbage collection by just defining `doABunchOfStuff` and `config` outside of the component:\n\n```jsx\nconst doABunchOfStuff = () =\u003e {\n  const a = 1 + 1;\n  console.log(\"result\", a);\n};\nconst config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\nfunction Component() {\n  return \u003cSomeotherComponent work={doABunchOfStuff} config={config} /\u003e;\n}\n```\n\n### Pushing State Down\n\nThere is one more technique I'd like to dive into, and it's one where you can minimize having to use `React.memo`. This technique involves restructuring your component tree hierarchy, so that state changes are localized to components that display them. Components that are meant to be rendered at the bottom of the tree, are passed down as `children`.\n\nIt's best understood by re-writing our example.\n\nTo refresh your memory, this the current component hierarchy of the example app:\n\n![Component Hierarchy](/blog/assets/blog/reducing-re-renders/component-hierarchy.png)\n\nWe are going to change the hierarchy so that less components need to re-rendered on a state change.\n\nFirst, let's put all the code related to the `counter` state in one component, called `FancyCounter`:\n\n```jsx\nconst ButtonWithFooterMemoized = React.memo(ButtonWithFooter);\n\nfunction FancyCounter({ length, children }) {\n  const [counter, setCounter] = useState(0);\n\n  const incrementOnClick = useRef(() =\u003e {\n    setCounter((prev) =\u003e prev + 1);\n  });\n\n  const configProp = useMemo(\n    () =\u003e ({\n      name: \"Special counter incrementer\",\n      listLength: length,\n    }),\n    [length]\n  );\n\n  return (\n    \u003cdiv\u003e\n      {/**\n    Note that we now will only render\n    FancyHeader and ButtonWithFooterMemoized,\n    but not FancyNumberListFormatter - we instead only include\n    a reference to some children passed down by the\n    parent component. \n    */}\n      \u003cFancyHeader counter={counter} /\u003e\n      {children}\n      \u003cButtonWithFooterMemoized\n        config={configProp}\n        onClick={incrementOnClick.current}\n      /\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nThis is the key point: now, `FancyCounter` will only re-render when `setCounter` is called - when this happens, its `children` prop\nwill be **unchanged**. `children` consists of React Elements passed down from the parent - as the parent has _not re-rendered_, these\nobjects remain unchanged - and React is smart enough to know that these do not need to be re-rendered.\n\nThis is how the rest of the re-written components look like:\n\n```jsx\nfunction RandomNumberListAndCounter({ length }: { length: number }) {\n  const [randomNumbers, setRandomNumbers] = useState(() =\u003e\n    generateListOfRandomNumbers(length)\n  );\n\n  useEffect(() =\u003e {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  return (\n    \u003cFancyCounter length={length}\u003e\n      {/** Note that this is no longer memoized! */}\n      \u003cFancyNumberListFormatter numberList={randomNumbers} /\u003e\n    \u003c/FancyCounter\u003e\n  );\n}\n```\n\nWe pass in `FancyNumberListFormatter` as the `children` of `FancyCounter`.\n`RandomNumberListAndCounter` will only re-render if its parent changes,\nand in our app, this will never happen. So `React.memo` for `FancyNumberListFormatter` is no longer needed!\n\nThis is what the new component hierarchy now looks like:\n\n![New Component Hierarchy](/blog/assets/blog/reducing-re-renders/push-state-down-hierarchy.png)\n\nWe can see that the React Profiler gives the same results:\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-flamegraph.png)\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-ranked.png)\n\nThis technique was lifted straight from Dan Abramov himself - and I highly recommend reading [his blog post on it](https://overreacted.io/before-you-memo/).\n\nThe basic idea is that the prop `children`, is a reference to some React elements created by the parent.\nIf the child component has re-rendered, and the `children` prop remains the same, React knows that `children` doesn't have to be rendered again.\n\n### Wrap Up\n\nI do want to emphasize though, that the optimizations I've mentioned above _could_ make your code a little harder to read.\nIn a lot of application code, readability and maintainability are higher concerns than performance. Libraries on the other hand need\nto emphasize on having more performant code.\n\nSo ideally, you'd use these optimizations when you need to, and not simply for the sake of \"performance\".\n\nAnd now below, I will summarize everything we've learnt in this entire series.\n\n**When we want to create stable references, we can:**\n\n1. Define objects and functions outside of a component, if they don't rely on variables defined in the component itself.\n2. If they do depend on variables defined in the component, we can use `useCallback` and `useMemo`.\n3. If they depend on variables defined in the component that are already stable, we can use `useRef` instead.\n\n**When we want to prevent redundant expensive computations on re-render, we can:**\n\n1. Pass an initialization function to `useState` or `useReducer`, if the result of the computation needs to be part of the component state.\n2. Use `useMemo`.\n\n**When we want to minimize redundant renders of a component, we can:**\n\n1. Use `React.memo` so that a component will only re-render if its props change.\n2. Reorganize the component tree, so that state changes are localized to components who consume that state.\n\nIn our final optimized example app, we have:\n\n- One component wrapped with `React.memo`\n- One object wrapped with `useMemo`\n- One callback stored in `useRef`\n\nA more naive approach would have been memoizing every component, object and callback in the app.\n"},"estimatedReadingTime":{"minutes":11,"words":1344,"text":"11 min read"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"avoiding-memoization"},"buildId":"sdgQCbCblRhJQea5TnrSF","assetPrefix":"/blog","runtimeConfig":{"basePath":"/blog"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>