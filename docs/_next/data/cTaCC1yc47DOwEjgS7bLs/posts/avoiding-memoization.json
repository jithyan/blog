{"pageProps":{"post":{"title":"Optimizing React: Part 3 - Avoiding Memoization","date":"2022-09-18T20:00:00.000Z","slug":"avoiding-memoization","author":{"name":"Jithya Nanayakkara"},"content":"\n---\n\nThis is the final article in a series covering techniques for optimizing React's performance by minimizing renders.\n\n1. [Part 1 - Understanding Renders](https://jithyan.github.io/blog/posts/understanding-renders)\n2. [Part 2 - Understanding Memoization](https://jithyan.github.io/blog/posts/understanding-memoization)\n3. Part 3 - Avoiding Memoization (this post)\n\n---\n\nIn the [last post](https://jithyan.github.io/blog/posts/understanding-memoization), we worked through an example application and used memoization to reduce unnecessary renders. However, as I said in the [very first article](https://jithyan.github.io/blog/posts/understanding-renders) of this series, there's a small cost with memoizing. And these costs _could_ add up significantly if we have tonnes of components being memoized.\n\nSo let's see how we could re-write our memoized example application from the [previous article](https://jithyan.github.io/blog/posts/understanding-memoization) in a way that minimizes usage of memoization.\n\n### Using useRef to replace useCallback or useMemo\n\nIn our example from the [last post](https://jithyan.github.io/blog/posts/understanding-memoization), we can see we're calling `useCallback` with an _empty_ dependency array:\n\n```javascript\nconst [counter, setCounter] = useState(0);\n\nconst incrementOnClick = useCallback(\n  () => {\n    setCounter((prev) => prev + 1);\n  },\n  // We don't pass anything into the array, and the React linter\n  // does not complain.\n  []\n);\n```\n\nWe can do this because `React` guarantees `setCounter` to be stable.\n\nFor scenarios where we have an empty dependency array for `useCallback` or `useMemo`, we could just store the variable in a ref instead.\nNote that this only applies for `useMemo` where you're using it for a stable reference, and **not** to reduce expensive computations.\n\nSo our example can be re-written as follows:\n\n```jsx\nconst incrementOnClick = useRef(() => {\n  setCounter((prev) => prev + 1);\n});\n\n<ButtonWithFooterMemoized\n  config={configProp}\n  onClick={incrementOnClick.current}\n/>;\n```\n\n`useRef` returns a reference to a [mutable object](https://blog.logrocket.com/immutability-in-react-ebe55253a1cc/). Like in `useState`, the initial value you pass is assigned\nonly once, no matter how many times the component re-renders. How `useRef` works is beyond the scope of this post, but you can [read more about it here](https://beta.reactjs.org/apis/react/useRef).\n\nThis technique is common in React libraries where returning stable references from hooks is important.\n\nSince `incrementOnClick.current` is a mutable object, its value will only change if we explicitly update it - so we don't need to care about re-renders of the component re-assigning it to a different value.\n\nThe only thing to watch out for, is that since it's a mutating object, React has no idea if it has changed - which is fine.\nUsually we only want React to know if a variable has changed when we synchronize with effects or display the data - that's why we use\nhooks like `useState`.\n\n### Defining variables outside a component\n\nNot everything needs to go into `useState`, or needs to be defined in a component. Too often, I find code like this:\n\n```jsx\nfunction Component() {\n  const doABunchOfStuff = () => {\n    const result = 1 + 1;\n    console.log(\"result\", result);\n  };\n  const config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\n  return <SomeotherComponent work={doABunchOfStuff} config={config} />;\n}\n```\n\nThe key point of the above code is that `doABunchOfStuff` and `config` isn't _referencing_ any data or functions defined **_in_ the component**.\n\nTherefore, it does not need to tie itself to React's rendering.\n\nWe can throw away concerns of stable references and garbage collection by just defining `doABunchOfStuff` and `config` outside of the component:\n\n```jsx\nconst doABunchOfStuff = () => {\n  const a = 1 + 1;\n  console.log(\"result\", a);\n};\nconst config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\nfunction Component() {\n  return <SomeotherComponent work={doABunchOfStuff} config={config} />;\n}\n```\n\n### Pushing State Down\n\nThere is one more technique I'd like to dive into, and it's one where you can minimize having to use `React.memo`. This technique involves restructuring your component tree hierarchy, so that state changes are localized to components that display them. Components that are meant to be rendered at the bottom of the tree, are passed down as `children`.\n\nIt's best understood by re-writing our example.\n\nTo refresh your memory, this the current component hierarchy of the example app:\n\n![Component Hierarchy](/blog/assets/blog/reducing-re-renders/component-hierarchy.png)\n\nWe are going to change the hierarchy so that less components need to re-rendered on a state change.\n\nFirst, let's put all the code related to the `counter` state in one component, called `FancyCounter`:\n\n```jsx\nconst ButtonWithFooterMemoized = React.memo(ButtonWithFooter);\n\nfunction FancyCounter({ length, children }) {\n  const [counter, setCounter] = useState(0);\n\n  const incrementOnClick = useRef(() => {\n    setCounter((prev) => prev + 1);\n  });\n\n  const configProp = useMemo(\n    () => ({\n      name: \"Special counter incrementer\",\n      listLength: length,\n    }),\n    [length]\n  );\n\n  return (\n    <div>\n      {/**\n    Note that we now will only render\n    FancyHeader and ButtonWithFooterMemoized,\n    but not FancyNumberListFormatter - we instead only include\n    a reference to some children passed down by the\n    parent component. \n    */}\n      <FancyHeader counter={counter} />\n      {children}\n      <ButtonWithFooterMemoized\n        config={configProp}\n        onClick={incrementOnClick.current}\n      />\n    </div>\n  );\n}\n```\n\nThis is the key point: now, `FancyCounter` will only re-render when `setCounter` is called - when this happens, its `children` prop\nwill be **unchanged**. `children` consists of React Elements passed down from the parent - as the parent has _not re-rendered_, these\nobjects remain unchanged - and React is smart enough to know that these do not need to be re-rendered.\n\nThis is how the rest of the re-written components look like:\n\n```jsx\nfunction RandomNumberListAndCounter({ length }: { length: number }) {\n  const [randomNumbers, setRandomNumbers] = useState(() =>\n    generateListOfRandomNumbers(length)\n  );\n\n  useEffect(() => {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  return (\n    <FancyCounter length={length}>\n      {/** Note that this is no longer memoized! */}\n      <FancyNumberListFormatter numberList={randomNumbers} />\n    </FancyCounter>\n  );\n}\n```\n\nWe pass in `FancyNumberListFormatter` as the `children` of `FancyCounter`.\n`RandomNumberListAndCounter` will only re-render if its parent changes,\nand in our app, this will never happen. So `React.memo` for `FancyNumberListFormatter` is no longer needed!\n\nThis is what the new component hierarchy now looks like:\n\n![New Component Hierarchy](/blog/assets/blog/reducing-re-renders/push-state-down-hierarchy.png)\n\nWe can see that the React Profiler gives the same results:\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-flamegraph.png)\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-ranked.png)\n\nThis technique was lifted straight from Dan Abramov himself - and I highly recommend reading [his blog post on it](https://overreacted.io/before-you-memo/).\n\nThe basic idea is that the prop `children`, is a reference to some React elements created by the parent.\nIf the child component has re-rendered, and the `children` prop remains the same, React knows that `children` doesn't have to be rendered again.\n\n### Wrap Up\n\nI do want to emphasize though, that the optimizations I've mentioned above _could_ make your code a little harder to read.\nIn a lot of application code, readability and maintainability are higher concerns than performance. Libraries on the other hand need\nto emphasize on having more performant code.\n\nSo ideally, you'd use these optimizations when you need to, and not simply for the sake of \"performance\".\n\nAnd now below, I will summarize everything we've learnt in this entire series.\n\n**When we want to create stable references, we can:**\n\n1. Define objects and functions outside of a component, if they don't rely on variables defined in the component itself.\n2. If they do depend on variables defined in the component, we can use `useCallback` and `useMemo`.\n3. If they depend on variables defined in the component that are already stable, we can use `useRef` instead.\n\n**When we want to prevent redundant expensive computations on re-render, we can:**\n\n1. Pass an initialization function to `useState` or `useReducer`, if the result of the computation needs to be part of the component state.\n2. Use `useMemo`.\n\n**When we want to minimize redundant renders of a component, we can:**\n\n1. Use `React.memo` so that a component will only re-render if its props change.\n2. Reorganize the component tree, so that state changes are localized to components who consume that state.\n\nIn our final optimized example app, we have:\n\n- One component wrapped with `React.memo`\n- One object wrapped with `useMemo`\n- One callback stored in `useRef`\n\nA more naive approach would have been memoizing every component, object and callback in the app.\n"},"estimatedReadingTime":{"minutes":11,"words":1344,"text":"11 min read"}},"__N_SSG":true}