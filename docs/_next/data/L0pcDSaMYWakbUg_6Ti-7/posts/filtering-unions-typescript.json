{"pageProps":{"post":{"title":"Filtering Unions in TypeScript","date":"2023-03-24T20:00:00.000Z","slug":"filtering-unions-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\nLet's say I have the following Union:\n\n```typescript\ntype Cake =\n    | { name: \"Nutella cheesecake\"; sugarLevel: \"low\" }\n    | { name: \"Fairy cupcake\"; sugarLevel: \"medium\" }\n    | { name: \"Strawberry shortcake\"; sugarLevel: \"high\" }\n    | { name: \"Rainbow cake\"; sugarLevel: \"high\" };\n```\n\nWhat if I want a new type, which is a union of all the names of cakes with a `sugarLevel` of `\"high\"`?\n\n```typescript\ntype Breakfast = \"Strawberry shortcake\" | \"Rainbow cake\";\n```\n\nWithout having to manually type out all the names which fit the criteria, we can achieve this instead by extracting the values from the `Cake` type:\n\n```typescript\ntype Breakfast = {\n    [CakeDescription in Cake as CakeDescription[\"name\"]]: CakeDescription[\"sugarLevel\"] extends \"high\"\n        ? CakeDescription[\"name\"]\n        : never;\n}[Cake[\"name\"]];\n\n// gives Breakfast = \"Strawberry shortcake\" | \"Rainbow cake\"\n```\n\nLet's breakdown what happens:\n\n1. First we need to create a new (temporary) object - that's why the type opens with a `{`. This object is mapping of `Cake[\"name\"]: Cake[\"name\"] | never`. **Note:** `Cake[\"name\"]` gives `\"Nutella cheesecake\" | \"Fairy cupcake\" | \"Strawberry shortcake\" | \"Rainbow cake\"`\n2. We then need to iterate over every value in the `Cake` union type. This is done using the `[value in union]` syntax.\n3. Every value we iterate over needs to be converted into a string, by indexing into the Cake object's `\"name\"` property. This is done using the `as` syntax.\n4. The previous step essentially created the key of the new object, now we need to associate it with a value. We still have access to the `Cake` value (I've named it `CakeDescription`) we're iterating over, so we check whether the `\"sugarLevel\"` equals `\"high\"` via the `extends` keyword.\n5. If it does equal `\"high\"` we return the name of the Cake, if not we return `never`.\n6. At the closing `}`, a new object type is created. We can extract all its values by passing a union of all its keys as the index - we already know the keys, as it's just `Cake[\"name\"]`. Which is why it ends with `}[Cake[\"name\"]];`\n"},"estimatedReadingTime":{"minutes":3,"words":336,"text":"3 min read"},"headings":[]},"__N_SSG":true}