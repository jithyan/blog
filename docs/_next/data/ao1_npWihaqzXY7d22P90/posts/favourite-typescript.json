{"pageProps":{"post":{"title":"My Top TypeScript Tips","date":"2022-10-01T20:00:00.000Z","slug":"favourite-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\r\nThis post covers a small collection of features and patterns I've found useful when working on TypeScript projects. Do note, what I've written is somewhat advanced, and isn't particularly useful for beginners.\r\n\r\n## Creating type safe utility functions\r\n\r\nThere are times when certain libraries or APIs don't have great type definitions, or unexpected types.\r\nFor example, you may have experienced the unpleasant suprise when `Object.keys` returns a `string[]` rather than the actual keys of the object ([and this is the intended behaviour by the TypeScript authors](https://github.com/Microsoft/TypeScript/issues/12870)).\r\n\r\nWhen you do come across this situation, don't shy away from creating utility functions whose sole purpose is to get better types.\r\nFor the `Object.keys` problem, I always create a type safe `Object.keys` helper in my TypeScript projects, like this:\r\n\r\n```jsx\r\nfunction getObjectKeys<Object extends Record<string, any>>(\r\n  obj: Object\r\n): Array<keyof Object> {\r\n  return Object.keys(obj);\r\n}\r\n```\r\n\r\n## Conditional types\r\n\r\nConditional types essentially allow you to check if a type `A`, is equal to, or is a subset of another type `B`.\r\nYou use it in the form `A extends B ? <true-expression> : <false-expression>`.\r\n\r\nOne example of where I use this, is when I create a `DeepPartial` utility type - the inbuilt `Partial` type only\r\nmakes the fields at the first level of an object optional, however `DeepPartial` makes every field at every level of the object optional:\r\n\r\n```jsx\r\ntype DeepPartial<Object extends Record<string, any>> = {\r\n  [Property in keyof Object]?:\r\n    Object[Property] extends Record<string, any>\r\n      ? DeepPartial<Object[Property]>\r\n      : Object[Property];\r\n};\r\n\r\ninterface Person {\r\n    name: {\r\n      first: string\r\n      last: string;\r\n    }\r\n    age: number\r\n}\r\ntype PartialPerson = DeepPartial<Person>;\r\n\r\n// Results in:\r\n{\r\n  name?: {\r\n    first?: string\r\n    last?: string;\r\n  }\r\n  age?: number\r\n}\r\n```\r\n\r\n1. DeepPartial takes in a Generic parameter, `Object`, and we constrain it to be a plain JS object\r\n2. We extract the keys in `Object` using: `keyof Object`\r\n3. We then iterate over every key using the operator `in`, and assign the key to the variable `Property`\r\n4. We add a new field to the resulting object with an optional field: `[Property]?`\r\n5. We check if the value at `Object[Property]` is another object using: `Object[Property] extends Record<string, any> ?`\r\n6. If it is an object, we recursively call `DeepPartial` on it\r\n7. Else, we just return the value at `Object[Property]`\r\n\r\n### Validation messages\r\n\r\nAnother place where I use conditional types, is to provide custom validation messages to arguments of a function.\r\n\r\n> I don't recommend you add this complexity to your application code, but this could be useful if you maintain a library.\r\n\r\n```jsx\r\ntype Validate<\r\n  Arg,\r\n  ExpectedType,\r\n  ErrorMsg extends string\r\n> = Arg extends ExpectedType ? Arg : ErrorMsg;\r\n\r\nfunction sendMessage<Arg>(\r\n  message: Validate<Arg, string, \"The message must be of type 'string'\">\r\n) {}\r\n\r\n// This won't compile!\r\n// Validate will return the specific type literal:\r\n//  \"The message must be of type 'string'\"\r\nsendMessage(1);\r\n\r\n// compiles without issues:\r\nsendMessage(\"hello\");\r\n```\r\n\r\n## Renaming Fields of an Object\r\n\r\nLet's say you need to add getter functions to an object, based on the existing fields in it.\r\nYou can use the `as` keyword when iterating over fields using `in`, to rename the existing fields:\r\n\r\n```jsx\r\ntype Getters<Object extends Record<string, any>> = {\r\n  [Property in keyof Object as `get${Capitalize<\r\n    string & Property\r\n  >}`]: () => Object[Property];\r\n};\r\n\r\nconst person = {\r\n  name: \"John\",\r\n  age: 18,\r\n};\r\ntype PersonAsGetters = Getters<typeof person>;\r\n\r\n// results in:\r\n{\r\n  getName: () => string;\r\n  getAge: () => number;\r\n}\r\n```\r\n\r\nNote: `Capitalize` is another inbuilt TypeScript utility.\r\n\r\n## Using `infer`\r\n\r\n`infer` is used with conditional types in order to extract types in the condition to another generic variable.\r\nThis is not something I particularly understand or can explain well, but I find looking at a couple of examples\r\nis more helpful in understanding `infer`.\r\n\r\n> Remember, we can only use `infer` in the `extends` clause of a conditional type.\r\n\r\nHere's an example where I convert a string from `kebab-case` to `snake_case`:\r\n\r\n```jsx\r\ntype KebabToSnakeCase<S extends string> = S extends `${infer Char}${infer Rest}`\r\n  ? Char extends \"-\"\r\n    ? `_${KebabToSnakeCase<Rest>}`\r\n    : `${Char}${KebabToSnakeCase<Rest>}`\r\n  : S;\r\n\r\ntype Result = KebabToSnakeCase<\"convert-this-kebab-case-to-snake-case\">;\r\n// Gives: \"convert_this_kebab_case_to_snake_case\";\r\n\r\n```\r\n\r\nWhat the following line:\r\n\r\n```jsx\r\nS extends `${infer Char}${infer Rest}`\r\n```\r\n\r\ndoes is that it checks if the generic `S` is a string that is of the template `${Char}${Rest}` - `Char` and `Rest` are named\r\ngeneric variables, and TypeScript will figure out what they are. If the string _does conform_ to it, `Char` will be the\r\nfirst character of a string, while `Rest` will be the remaining characters in the string.\r\n\r\nHere's another example where I extract the value from an object, given the dot-separated path - just like in Lodash's `get` utility:\r\n\r\n```jsx\r\ntype ExtractTypeFromPath<\r\n  Path extends string,\r\n  Object extends Record<string, any>\r\n> = Path extends `${infer Property}.${infer RestOfPath}`\r\n  ? ExtractTypeFromPath<RestOfPath, Object[Property]>\r\n  : Object[Path];\r\n\r\ninterface Person {\r\n  data: {\r\n    firstName: string;\r\n    lastName: string;\r\n    sensitive: {\r\n      age: number;\r\n    };\r\n  };\r\n}\r\n// Results in number\r\ntype TypeOfAge = ExtractTypeFromPath<\"data.sensitive.age\", Person>;\r\n```\r\n\r\n## Dynamically inferring types from JavaScript\r\n\r\nIn the examples so far, we've been dealing exclusively with types - which have no\r\nimpact on the actual execution of our app - after all, the compiler just strips out\r\nall the type definitions.\r\n\r\nHowever, one of the most useful patterns I've found is to derive types from\r\nactual JavaScript objects. The trick is to use `as const` to\r\nensure that the most accurate types would be derived.\r\n\r\nFor example, if you were to do this:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"];\r\n```\r\n\r\n`typeof fieldNames` would give you `string[]`\r\n\r\nHowever, if we did this instead:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\n```\r\n\r\nThis would give you `(\"name\" | \"age\")[]` - which is far more useful. We can then extract the values in the array using:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\ntype FieldName = typeof fieldNames[number];\r\n\r\n// results in: FieldName = \"name\" | \"age\"\r\n```\r\n\r\nBelow is an example of a situation where I used this approach. My memory of it is rather hazy, but from what I recall,\r\nI needed to make a GET request\r\nto a REST API, and I could specify what fields in the data I want returned in the response. I simply\r\nhad to pass the field names as query parameters in the URL (in a comma separated format).\r\n\r\nRather than putting the field names as query parameters in a hard to read URL, I decided to put the fields I want\r\nin an array, then convert the array to the appropriate query parameters. This was quite useful, because I discovered in production\r\nthat there were multiple other field names with the data I needed, and I could easily add them to the array over time.\r\n\r\nHowever, TypeScript types become an issue - how does it know what the response object type is\r\ngiven my JavaScript array?\r\n\r\nThis is how I did it:\r\n\r\n```jsx\r\nconst pickFields = [\"age\", \"isMember\"] as const;\r\n\r\ninterface ApiResponse {\r\n  age: number;\r\n  name: {\r\n    firstName: string;\r\n    lastName: string;\r\n  };\r\n  height: string;\r\n  isMember: boolean;\r\n}\r\n// Note that I'm not specifying pickFields\r\n// is of type \"Array<keyof ApiResponse>\"!\r\n\r\n/**\r\n * I'm constraining it to only the fields I'm interested in\r\n */\r\nasync function getPersonDetails<\r\n  RequestedFields extends ReadonlyArray<typeof pickFields[number]>\r\n>(\r\n  ...fieldNames: RequestedFields\r\n): Promise<{\r\n  [Field in RequestedFields extends ReadonlyArray<infer FieldNameValue>\r\n    ? FieldNameValue\r\n    : never]: ApiResponse[Field];\r\n}> {\r\n  return callRestApi(\"/v1/person\", fieldNames) as any;\r\n}\r\n\r\n// Will give you { age: number; isMember: boolean; }\r\nconst response = await getPersonDetails(...pickFields)\r\n```\r\n\r\nThis is the really cool part of making `pickFields` a `const` - TypeScript\r\ncan figure out that the values in `pickFields` **are a member of** `ApiResponse`!\r\n\r\nIf we put the string \"woof\" into `pickFields`, `getPersonDetails` will fail compilation with an error, because \"woof\" is not a field in `ApiResponse`!\r\n\r\nLikewise, putting it into the arguments of `getPersonDetails`, will also fail compilation for the same reason.\r\n"},"estimatedReadingTime":{"minutes":10,"words":1279,"text":"10 min read"},"headings":["Creating type safe utility functions","Conditional types","Renaming Fields of an Object","Using `infer`","Dynamically inferring types from JavaScript"]},"__N_SSG":true}