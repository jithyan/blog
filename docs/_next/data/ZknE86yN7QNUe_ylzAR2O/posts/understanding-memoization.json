{"pageProps":{"post":{"title":"Optimizing React: Part 2 - Understanding Memoization","date":"2022-09-12T20:00:00.000Z","slug":"understanding-memoization","author":{"name":"Jithya Nanayakkara"},"content":"\n---\n\nThis is the second article in a series covering common techniques for optimizing React's performance by minimizing renders.\n\n1. [Part 1 - Understanding Renders](https://jithyan.github.io/blog/posts/understanding-renders)\n2. Part 2 - Understanding Memoization (this post)\n3. [Part 3 - Avoiding Memoization](https://jithyan.github.io/blog/posts/avoiding-memoization)\n\n---\n\nIn the [previous article](https://jithyan.github.io/blog/posts/understanding-renders), we've covered why a component can re-render, and how variables are given new references on each render.\n\nNow that we have a better understanding of the basics, we can begin to cover how we can optimize a React app.\nHowever in order to do so, we need to actually work on an example application. The example I'm about to introduce is incredibly silly and quite long, but we need it to be a few components deep so we could systematically walk through how it could be optimized.\n\n### A Random Number List Generator and Counter Example\n\nThis is what our example app looks like:\n\n![Picture of example app](/blog/assets/blog/reducing-re-renders/app-first-load.png)\n\nAnd it does the following:\n\n- Displays a list of random numbers.\n- Each random number is styled either with a black or white background. How this is decided is by generating _another_ random number, and checking if it's even or odd.\n- We also give the user a button to click, which increments a counter.\n\nBelow is the code for the above app (I've stripped out any CSS, for simplicity):\n\n```jsx\nReactDOM.render(<App />, rootElement);\n\n// The Parent component - note that it has no state\n// and passes a fixed prop to RandomNumberListAndCounter\nfunction App() {\n  return (\n    <div className=\"App\">\n      <RandomNumberListAndCounter length={10} />\n    </div>\n  );\n}\n\nfunction RandomNumberListAndCounter({ length }) {\n  const [counter, setCounter] = useState(0);\n  // We keep the random number list in state, so that we can control\n  // when the list of random numbers is updated, independent of re-renders of the component.\n  const [randomNumbers, setRandomNumbers] = useState(\n    generateListOfRandomNumbers(length)\n  );\n\n  // Generate a different set of random numbers every time length changes\n  useEffect(() => {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  const incrementOnClick = () => {\n    setCounter((prev) => prev + 1);\n  };\n\n  // An object that is the prop to ButtonWithFooter\n  // A little unusual, but sometimes you may need to pass\n  // complex objects to a component\n  const configProp = {\n    name: \"Special counter incrementer\",\n    listLength: length,\n  };\n\n  return (\n    <div>\n      {/* Displays the counter */}\n      <FancyHeader counter={counter} />\n      {/* Displays the styled list of random numbers */}\n      <FancyNumberListFormatter numberList={randomNumbers} />\n      {/* Increments the counter, and shows how many random numbers are shown*/}\n      <ButtonWithFooter config={configProp} onClick={incrementOnClick} />\n    </div>\n  );\n}\n\nfunction FancyHeader({ counter }) {\n  return (\n    <hgroup>\n      <h1>My Special Counter</h1>\n      <h2>Clicked {counter} times.</h2>\n    </hgroup>\n  );\n}\n\nfunction FancyNumberListFormatter({ numberList }) {\n  return (\n    <div>\n      {numberList.map((number, i) => (\n        <RandomlyStyledNumber number={number} key={`${number}-${i}`} />\n      ))}\n    </div>\n  );\n}\n\nfunction RandomlyStyledNumber({ number }) {\n  const [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);\n\n  // I'm skipping showing any styling\n  const evenStyle = {};\n  const oddStyle = {};\n\n  return <span style={isEven ? evenStyle : oddStyle}>{number}</span>;\n}\n\nfunction ButtonWithFooter({ config, onClick }) {\n  return (\n    <>\n      <div>\n        <button onClick={onClick}>{config.name}</button>\n      </div>\n      {/* \n        Normally you wouldn't include a footer with a button, but this is only\n        for the purpose of the example \n      */}\n      <footer>\n        <em>Number of random numbers shown: {config.listLength}</em>\n      </footer>\n    </>\n  );\n}\n```\n\nThe functions to generate the random numbers use the browser `crypto` library.\nI've written it in a way so that it's **really** slow.\n\nIt is **not important** to understand how they work, I'm just including it if you're curious:\n\n```typescript\nfunction getExpensiveRandomNumber() {\n  return new Array(1000)\n    .fill(null)\n    .map(\n      () => Array.from(window.crypto.getRandomValues(new Uint16Array(1000)))[0]\n    )[0];\n}\n\nfunction generateListOfRandomNumbers(length) {\n  return new Array(length).fill(null).map(getExpensiveRandomNumber);\n}\n```\n\nThis is the hierarchy of the components:\n\n![Component Hierarchy](/blog/assets/blog/reducing-re-renders/component-hierarchy.png)\n\nSo how does this app perform?\nTo answer this question, I'm going to use the React DevTools Profiler to measure how long it takes to render all the components:\n\n- I just want the `RandomNumberListAndCounter` to re-render, so I can do this by clicking on the\n  increment counter button.\n- Before clicking the counter button, I hit record on the profiler, then after I see the counter increment, I stop recording.\n- If any renders took place, the profile will spit out a flame graph of how long each component took to render.\n\n![First click](/blog/assets/blog/reducing-re-renders/app-first-click.png)\n\n![First click profiler](/blog/assets/blog/reducing-re-renders/app-first-click-profiler.png)\n\nA few observations about the profiler:\n\n1. We can see the total time it took to render `RandomNumberListAndCounter` and all its children was a whopping **1.25 seconds**!\n2. `App` did not re-render (we can tell because of its gray color).\n3. Even though only the text \"Clicked 1 times\" is what changed, all the child components of `RandomNumberListAndCounter` _re-rendered_.\n\n## Optimizing the Example\n\nWe desperately need to fix the slow re-rendering of the example every time we increment the counter. And we can actually do this without memoization, by using `useState`'s **initialization function**.\n\nCurrently, every time we render the component, we're generating and throwing away the random number list.\nBy passing an initialization function to `useState`, React will only invoke the function once (on the component's first render).\n\nThis is the existing problem code:\n\n```javascript\n// In RandomNumberListAndCounter:\nconst [randomNumbers, setRandomNumbers] = useState(\n  generateListOfRandomNumbers(length)\n);\n\n// In RandomStyledNumber:\nconst [isEven] = useState(getExpensiveRandomNumber() % 2 === 0);\n```\n\nAnd this is the fixed code:\n\n```javascript\n// In RandomNumberListAndCounter:\nconst [randomNumbers, setRandomNumbers] = useState(() =>\n  generateListOfRandomNumbers(length)\n);\n\n// In RandomStyledNumber:\nconst [isEven] = useState(() => getExpensiveRandomNumber() % 2 === 0);\n```\n\n> Note that when we first load the App, its initial render will still be painfully slow. But at least we can tackle slow re-renders easily.\n\nLet's see how this improves the profiler result:\n\n![Initialize state only once](/blog/assets/blog/reducing-re-renders/profiler-init-state.png)\n\n0.9ms - A dramatic improvement!\n\n> At this point, you'd normally stop optimizing your app (unless you expect it to grow in complexity). A 0.9ms re-render time is plenty fast. However, for the sake of learning, we're going to optimize the rest of the app.\n\nBut notice how all the `RandomlyStyledNumber`, `ButtonWithFooter` and `FancyNumberListFormatter` components continue to re-render. These renders are unnecessary given the only thing that changes is the unrelated counter text.\n\nThis where `React.memo` comes in. If we pass a component into `React.memo`, it will only re-render it if its props have changed between re-renders of its parent. Parent components can re-render all they like, but as long as the props passed to the memoized component remain the same, the cached React Elements will be what's returned.\n\nThis is how we call `React.memo`:\n\n```javascript\nconst MyComponentMemoized = React.memo(MyComponent);\n\n// and use it like a regular component in JSX:\n<MyComponentMemoized />;\n```\n\nSo should we wrap all our components in the example with `React.memo`?\n\nNo. It's neither necessary nor optimal.\n\nIf look at the component hierarchy diagram again, we can see that the memoizing the following components is redundant:\n\n- `App`: This is the root component. It's pointless memoizing this as it has no parent component to trigger any re-renders.\n- `RandomNumberListAndCounter`: In the context of our example, this component will only re-render when its state, `counter`, changes. Its parent component, `App`, doesn't also have any state so it would never re-render. Therefore wrapping it with `React.memo` is redundant, as memoized components will continue to re-render when its internal state changes (which is what we want).\n- `RandomlyStyledNumber`: This component will **only** re-render when its parent, `FancyNumberListFormatter`, re-renders. Therefore, only memoizing its parent is sufficient.\n- `FancyHeader`: This component depends on `counter`, as its passed as a prop. We know that the only thing in our app that triggers a re-render is the `counter` being updated. Therefore, wrapping this in `React.memo` is redundant.\n\nSo only these 2 components would benefit from memo:\n\n1. `FancyNumberListFormatter`\n2. `ButtonWithFooter`\n\nBoth of the above components depend on the `length` prop, and not `counter`. When `counter` changes, these components end up re-rendering, so they're good candidates for memoization.\n\nLet's go ahead and do just that:\n\n```javascript\nconst FancyNumberListFormatterMemoized = React.memo(FancyNumberListFormatter);\nconst ButtonWithFooterMemoized = React.memo(ButtonWithFooter);\n\nfunction RandomNumberListAndCounter({ length }: { length: number }) {\n  const [counter, setCounter] = useState(0);\n  const [randomNumbers, setRandomNumbers] = useState(() =>\n    generateListOfRandomNumbers(length)\n  );\n\n  useEffect(() => {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  const incrementOnClick = () => {\n    setCounter((prev) => prev + 1);\n  };\n\n  const configProp = {\n    name: \"Special counter incrementer\",\n    listLength: length,\n  };\n\n  return (\n    <div>\n      <FancyHeader counter={counter} />\n      <FancyNumberListFormatterMemoized numberList={randomNumbers} />\n      <ButtonWithFooterMemoized\n        config={configProp}\n        onClick={incrementOnClick}\n      />\n    </div>\n  );\n}\n```\n\nBefore we check the profiler, I'm going to throttle my CPU speed by 6x in Chrome - so that it simulates users who don't have a developer grade laptop:\n\n![How to throttle CPU](/blog/assets/blog/reducing-re-renders/throttle-cpu.png)\n\nAnd now let's take a look at the React profiler, where I measure what happens after I click the counter button:\n\n![Flamegraph of memoized components](/blog/assets/blog/reducing-re-renders/memo-flamegraph.png)\n\nLooking good - all components that don't need to re-render aren't rendering according to this flamegraph (indicated by the grayed out bars).\n\nBut the flamegraph isn't showing all the re-rendering components, so let's switch views to \"Ranking\":\n\n![Ranking of memoized components](/blog/assets/blog/reducing-re-renders/memo-ranked.png)\n\nOnly two components should re-render: `RandomNumberListFormatter` and `FancyHeader`. `RandomNumberListFormatter` contains the state `counter`, which changes, and `FancyHeader` takes in the prop `counter`.\n\nBut it also looks like `ButtonWithFooter` is re-rendering, even though it doesn't care about the `counter` value.\n\nSo why would `ButtonWithFooter` re-render despite being memoized and having no props change?\n\nAllow me to yank out the cause of this:\n\n```javascript\n// New object assignment\nconst incrementOnClick = () => {\n  setCounter((prev) => prev + 1);\n};\n\n// New object assignment\nconst configProp = {\n  name: \"Special counter incrementer\",\n  listLength: length,\n};\n\n// Even though semantically the same, config and incrementOnClick\n// are different objects on each render\n<ButtonWithFooterMemoized config={configProp} onClick={incrementOnClick} />;\n```\n\nThe thing to note is that when `React.memo` compares the previous props with the new props, it uses [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) to compare\nif they've changed. This is a shallow comparison - so two objects that have the same values but different memory references,\nare not equal (remember `{} === {}` evaluates to `false`).\n\nAnd in our example, we're creating **new objects** for `incrementOnClick` and `configProp` on _every render_.\n\nWe can easily fix this by using `useMemo`, to cache the objects:\n\n```jsx\nconst incrementOnClick = useMemo(\n  () => () => {\n    setCounter((prev) => prev + 1);\n  },\n  []\n);\n\n/**\n * We only create a new object when the `length` changes.\n */\nconst configProp = useMemo(\n  () => ({\n    name: \"Special counter incrementer\",\n    listLength: length,\n  }),\n  [length]\n);\n```\n\nAnd the new Ranked profiler result is:\n\n![Profiler after useMemo](/blog/assets/blog/reducing-re-renders/profiler-usememo.png)\n\nNow only the two expected components re-render.\n\nBut... notice the awkward syntax for the incrementer. Since `useMemo` accepts a function, and caches the return value of that function,\nwe need to pass in a function that returns a function.\nInstead, we can use `useCallback` instead of `useMemo` - its explicit purpose is to cache callbacks (aka functions):\n\n```jsx\nconst incrementer = useCallback(() => {\n  setCounter((prev) => prev + 1);\n}, []);\n```\n\nNow that we understand how to use memoization in React, in the [next article](https://jithyan.github.io/blog/posts/avoiding-memoization), I'm going to cover how we can _avoid_ memoization!\n"},"estimatedReadingTime":{"minutes":6,"words":1874,"text":"6 min read"}},"__N_SSG":true}