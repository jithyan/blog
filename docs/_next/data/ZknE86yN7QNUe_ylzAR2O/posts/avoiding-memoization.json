{"pageProps":{"post":{"title":"Optimizing React: Part 3 - Avoiding Memoization","date":"2022-09-18T20:00:00.000Z","slug":"avoiding-memoization","author":{"name":"Jithya Nanayakkara"},"content":"\n---\n\nThis is the final article in a series covering common techniques for optimizing React's performance by minimizing renders.\n\n1. [Part 1 - Understanding Renders](https://jithyan.github.io/blog/posts/understanding-renders)\n2. [Part 2 - Understanding Memoization](https://jithyan.github.io/blog/posts/understanding-memoization)\n3. Part 3 - Avoiding Memoization (this post)\n\n---\n\n## But we can do better\n\nIn the [last post](https://jithyan.github.io/blog/posts/understanding-memoization), we worked through an example application and used memoization to reduce unnecessary renders. However, as I said in the [very first article](https://jithyan.github.io/blog/posts/understanding-renders) of this series, there's a small cost with memoizing. And those costs _could_ add up significantly if we have tonnes of components being memoized.\n\nSo let's see how we could re-write our memoized application in a way to minimize calls to memo.\n\n### Using useRef to replace useCallback or useMemo\n\nIn our example from the [last post](https://jithyan.github.io/blog/posts/understanding-memoization), we can see we're calling `useCallback` with an empty dependency array:\n\n```javascript\nconst [counter, setCounter] = useState(0);\n\nconst incrementOnClick = useCallback(() => {\n  setCounter((prev) => prev + 1);\n}, []);\n```\n\nWe can do this because `React` guarantees `setCounter` to be stable.\n\nFor scenarios where we have an empty dependency array for `useCallback` or `useMemo`, we could just store the variable in a ref instead.\nNote that this only applies for `useMemo` where you're using it for a stable reference, and **not** to reduce expensive computations.\n\nSo our example can be re-written as follows:\n\n```jsx\nconst incrementOnClick = useRef(() => {\n  setCounter((prev) => prev + 1);\n});\n\n<ButtonWithFooterMemoized\n  config={configProp}\n  onClick={incrementOnClick.current}\n/>;\n```\n\n`useRef` returns a reference to a mutable object. Like in `useState`, the initial value you pass is assigned\nonly once, no matter how many times the component re-renders. How `useRef` works is beyond the scope of this post, but you can [read more on it here](https://beta.reactjs.org/apis/react/useRef).\n\nThis technique is common in React libraries where returning stable references from hooks is important.\n\nSince `incrementOnClick.current` is a mutable object, its value will only change if we explicitly update it - so we don't need to care about re-renders of the component re-assigning it to a different value.\n\nThe only thing to watch out for, is that since it's a mutating object, React has no idea if it has changed - which is fine.\nUsually we only want React to know if a variable has changed when we synchronize with effects or display the data - that's why we use\nhooks like `useState`.\n\n### Defining variables outside a component\n\nNot everything needs to go into `useState`, or needs to be defined in a component. Too often, I find code like this:\n\n```jsx\nfunction Component() {\n  const doABunchOfStuff = () => {\n    const result = 1 + 1;\n    console.log(\"result\", result);\n  };\n  const config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\n  return <SomeotherComponent work={doABunchOfStuff} config={config} />;\n}\n```\n\nThe key point of the above code is that `doABunchOfStuff` and `config` isn't _referencing_ any data defined **in the component**.\n\nIt does not need to tie itself to React's rendering.\n\nWe can throw away concerns of stable references and garbage collection by just defining `doABunchOfStuff` and `config` outside of the component:\n\n```jsx\nconst doABunchOfStuff = () => {\n  const a = 1 + 1;\n  console.log(\"result\", a);\n};\nconst config = { title: \"Beautiful example\", theme: \"skyblue\" };\n\nfunction Component() {\n  return <SomeotherComponent work={doABunchOfStuff} config={config} />;\n}\n```\n\n### Pushing State Down\n\nThere is one more technique I'd like to dive into, and it's one where you can minimize having to use `React.memo`. This technique involves restructuring your component tree hierarchy, so that state changes are localized to components that display them. Components that are meant to be rendered at the bottom of the tree, are passed down as `children`.\n\nIt's best understood by re-writing our example.\n\nFirst, let's put all the code related to the `counter` in one component, called `FancyCounter`:\n\n```jsx\nconst ButtonWithFooterMemoized = React.memo(ButtonWithFooter);\n\nfunction FancyCounter({ length, children }) {\n  const [counter, setCounter] = useState(0);\n\n  const incrementOnClick = useRef(() => {\n    setCounter((prev) => prev + 1);\n  });\n\n  const configProp = useMemo(\n    () => ({\n      name: \"Special counter incrementer\",\n      listLength: length,\n    }),\n    [length]\n  );\n\n  return (\n    <div>\n      <FancyHeader counter={counter} />\n      {children}\n      <ButtonWithFooterMemoized\n        config={configProp}\n        onClick={incrementOnClick.current}\n      />\n    </div>\n  );\n}\n```\n\nThis is the key point: now, `FancyCounter` will only re-render when `setCounter` is called - when this happens, its `children` prop\nwill be **unchanged**. `children` consists of React Elements passed down from the parent - as the parent has _not re-rendered_, these\nobjects remain unchanged - and React is smart enough to know that these do not need to be re-rendered.\n\nThis is how the rest of the re-written components look like:\n\n```jsx\nfunction RandomNumberListAndCounter({ length }: { length: number }) {\n  const [randomNumbers, setRandomNumbers] = useState(() =>\n    generateListOfRandomNumbers(length)\n  );\n\n  useEffect(() => {\n    setRandomNumbers(generateListOfRandomNumbers(length));\n  }, [length]);\n\n  return (\n    <FancyCounter length={length}>\n      <FancyNumberListFormatter numberList={randomNumbers} />\n    </FancyCounter>\n  );\n}\n```\n\nWe pass in `FancyNumberListFormatter` as the `children` of `FancyCounter`. `RandomNumberListAndCounter` will only re-render if its parent changes,\nand in our app, this will never happen. So `React.memo` for `FancyNumberListFormatter` is no longer needed!\n\nWe can see the React Profiler gives the same results:\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-flamegraph.png)\n\n![Push state down flamegraph](/blog/assets/blog/reducing-re-renders/pushed-state-ranked.png)\n\nThis technique was lifted straight from Dan Abramov himself - and I highly recommend reading [his blog post on it](https://overreacted.io/before-you-memo/).\n\nThe basic idea is that the prop `children`, is a reference to some React elements created by the parent.\nIf the child component has re-rendered, and the `children` prop remains the same, React knows that `children` doesn't have to be rendered again.\n\n### Wrap Up\n\nWhen we want to create stable references, we can:\n\n1. Define objects and functions outside of a component, if they don't rely on variables defined in the component itself.\n2. If they do depend on variables defined in the component, we can use `useCallback` and `useMemo`.\n3. If they depend on variables defined in the component that are already stable, we can use `useRef` instead.\n\nWhen we want to prevent redundant expensive computations on re-render, we can:\n\n1. Pass an initialization function to `useState`, if the result of the computation needs to be part of the component state.\n2. Use `useMemo`.\n\nWhen we want to minimize redundant renders of a component, we can:\n\n1. Use `React.memo` so that a component will only re-render if its props change.\n2. Reorganize the component tree, so that state changes are localized to components who consume that state.\n\nIn our final optimized example app, we have:\n\n- One component wrapped with `React.memo`\n- One object wrapped with `useMemo`\n- One callback stored in `useRef`\n\nA more naive approach would have been memoizing every component, object and callback in the app.\n"},"estimatedReadingTime":{"minutes":4,"words":1127,"text":"4 min read"}},"__N_SSG":true}