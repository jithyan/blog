{"pageProps":{"post":{"title":"Filtering Unions in TypeScript","date":"2023-03-18T20:00:00.000Z","slug":"filtering-unions-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\nLet's say I have the following Union:\n\n```typescript\ntype Cake =\n    | { name: \"Nutella cheesecake\"; sugarLevel: \"low\" }\n    | { name: \"Fairy cupcake\"; sugarLevel: \"medium\" }\n    | { name: \"Strawberry shortcake\"; sugarLevel: \"high\" }\n    | { name: \"Rainbow cake\"; sugarLevel: \"high\" };\n```\n\nWhat if I want a new type, `Breakfast`, which is a union of all the names of cakes with a `sugarLevel` of `\"high\"`, but without manually having to type it out like below?\n\n```typescript\ntype Breakfast = \"Strawberry shortcake\" | \"Rainbow cake\";\n```\n\nWe can filter the objects in the `Cake` type to those that match our criteria, and extract the names like this:\n\n```typescript\ntype Breakfast = {\n    [CakeDescription in Cake as CakeDescription[\"name\"]]: CakeDescription[\"sugarLevel\"] extends \"high\"\n        ? CakeDescription[\"name\"]\n        : never;\n}[Cake[\"name\"]];\n\n// gives Breakfast = \"Strawberry shortcake\" | \"Rainbow cake\"\n```\n\nThat bit of Typescript looks intimidating, so let's breakdown what happens:\n\n1. We first want to extract all the _names_ of `Cake`. As every object in the `Cake` union has a `name` property, we can get a union of all the names using `Cake['name']`.\n2. We need to iterate over all the `Cake` objects. The only way I know of achieving this is by creating a new object and using the `in` operator. A simple example of this is:\n\n```typescript\ntype PersonFields = \"name\" | \"age\" | \"birthday\";\n\ntype Person = {\n    [Field in PersonFields]: string;\n};\n```\n\n`Person` above is equivalent to:\n\n```typescript\ntype Person = { name: string; age: string; birthday: string };\n// this can also be written as Record<\"name\"|\"age\"|\"birthday\", string>\n```\n\n3. If we try to do the same thing with `Cake`, we come to a problem:\n\n```typescript\n// this will not work!\ntype CakeObject = {\n    [CakeDescription in Cake]: string;\n};\n```\n\n> Type 'Cake' is not assignable to type 'string | number | symbol'.\n\nThe reason you get an error, is that `CakeDescription` is an object of type `Cake`, and properties of objects need to be either strings, numbers or Symbols.\n\nThis is where the `as` operator comes into play. We use it do some transformation of the current value (i.e. `CakeDescription`) in the interation:\n\n```typescript\ntype CakeObject = {\n    [CakeDescription in Cake as CakeDescription[\"name\"]]: string;\n};\n```\n\nWe simply accessed the `name` property in `CakeDescription`. This results in the equivalent type:\n\n```typescript\ntype CakeObject = Record<\n    | \"Strawberry shortcake\"\n    | \"Rainbow cake\"\n    | \"Nutella cheesecake\"\n    | \"Fairy cupcake\",\n    string\n>;\n```\n\n4. So far, every field in `CakeObject` has a value type of `string`. We need this to be the actual name of the cake we're currently iterating over. This can be done easily enough, as the value portion (the part after `:`) still has access to `CakeDescription`:\n\n```typescript\ntype CakeObject = {\n    [CakeDescription in Cake as CakeDescription[\"name\"]]: CakeDescription[\"name\"];\n};\n```\n\nWhich is equivalent to:\n\n```typescript\ntype CakeObject = {\n    \"Strawberry shortcake\": \"Strawberry shortcake\";\n    \"Rainbow cake\": \"Rainbow cake\";\n    \"Nutella cheesecake\": \"Nutella cheesecake\";\n    \"Fairy cupcake\": \"Fairy cupcake\";\n};\n```\n\n5. However, we are only interested in `Cake`s with a `sugarLevel` of `\"high\"`. We introduce a condition using the `extends` operator, and return the name of the cake only if its `sugarLevel` is `\"high\"`, and `never` if it isn't:\n\n```typescript\ntype CakeObject = {\n    [CakeDescription in Cake as CakeDescription[\"name\"]]: CakeDescription[\"sugarLevel\"] extends \"high\"\n        ? CakeDescription[\"name\"]\n        : never;\n};\n```\n\nWhich is equivalent to:\n\n```typescript\ntype CakeObject = {\n    \"Strawberry shortcake\": \"Strawberry shortcake\";\n    \"Rainbow cake\": \"Rainbow cake\";\n    \"Nutella cheesecake\": never;\n    \"Fairy cupcake\": never;\n};\n```\n\n`never` is kind of like the opposite of `any`. It represents impossible types and Typescript doesn't allow you to perform any operation on them.\n\n6. The final step is to get all the values of `CakeObject`. We can do this by passing in the union of all its keys as the index:\n\n```typescript\ntype CakeObject = {\n    [CakeDescription in Cake as CakeDescription[\"name\"]]: CakeDescription[\"sugarLevel\"] extends \"high\"\n        ? CakeDescription[\"name\"]\n        : never;\n};\n\ntype Breakfast = CakeObject[keyof CakeObject];\n```\n\nAll the `never` types are removed from the resulting union, giving `\"Strawberry shortcake\" | \"Rainbow cake\"`!\n\nWe could also have written it as:\n\n```typescript\ntype Breakfast = CakeObject[Cake[\"name\"]];\n```\n\nAs the keys of `CakeObject` are all the `name` values of `Cake`.\n\nKnowing this, we can extract the new type in one step as:\n\n```typescript\ntype Breakfast = {\n    [CakeDescription in Cake as CakeDescription[\"name\"]]: CakeDescription[\"sugarLevel\"] extends \"high\"\n        ? CakeDescription[\"name\"]\n        : never;\n}[Cake[\"name\"]];\n```\n"},"estimatedReadingTime":{"minutes":6,"words":695,"text":"6 min read"},"headings":[]},"__N_SSG":true}