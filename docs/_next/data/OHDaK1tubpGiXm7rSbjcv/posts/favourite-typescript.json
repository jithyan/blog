{"pageProps":{"post":{"title":"Useful Advanced Typescript Features","date":"2022-10-01T20:00:00.000Z","slug":"favourite-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\r\nThis post covers a small collection of features and patterns I've found useful when working on TypeScript projects. Do note, what I've written is somewhat advanced, and isn't particularly useful for beginners.\r\n\r\n## Creating type safe utility functions\r\n\r\nThere are times when certain libraries or APIs don't have great type definitions, or unexpected types.\r\nFor example, you may have experienced the unpleasant suprise when `Object.keys` returns a `string[]` rather than the actual keys of the object ([and this is the intended behaviour by the TypeScript authors](https://github.com/Microsoft/TypeScript/issues/12870)).\r\n\r\nWhen you do come across this situation, don't shy away from creating utility functions whose sole purpose is to get better types.\r\nFor the `Object.keys` problem, I always create a type safe `Object.keys` helper in my TypeScript projects, like this:\r\n\r\n```jsx\r\nfunction getObjectKeys<Object extends Record<string, any>>(\r\n  obj: Object\r\n): Array<keyof Object> {\r\n  return Object.keys(obj);\r\n}\r\n```\r\n\r\n## Conditional types\r\n\r\nConditional types essentially allow you to check if a type `A`, is equal to, or is a subset of another type `B`.\r\nYou use it in the form `A extends B ? <true-expression> : <false-expression>`.\r\n\r\nOne example of where I use this, is when I create a `DeepPartial` utility type - the inbuilt `Partial` type only\r\nmakes the fields at the first level of an object optional, however `DeepPartial` makes every field at every level of the object optional:\r\n\r\n```jsx\r\ntype DeepPartial<Object extends Record<string, any>> = {\r\n  [Property in keyof Object]?:\r\n    Object[Property] extends Record<string, any>\r\n      ? DeepPartial<Object[Property]>\r\n      : Object[Property];\r\n};\r\n\r\ninterface Person {\r\n    name: {\r\n      first: string\r\n      last: string;\r\n    }\r\n    age: number\r\n}\r\ntype PartialPerson = DeepPartial<Person>;\r\n\r\n// Results in:\r\n{\r\n  name?: {\r\n    first?: string\r\n    last?: string;\r\n  }\r\n  age?: number\r\n}\r\n```\r\n\r\n1. DeepPartial takes in a Generic parameter, `Object`, and we constrain it to be a plain JS object\r\n2. We extract the keys in `Object` using: `keyof Object`\r\n3. We then iterate over every key using the operator `in`, and assign the key to the variable `Property`\r\n4. We add a new field to the resulting object with an optional field: `[Property]?`\r\n5. We check if the value at `Object[Property]` is another object using: `Object[Property] extends Record<string, any> ?`\r\n6. If it is an object, we recursively call `DeepPartial` on it\r\n7. Else, we just return the value at `Object[Property]`\r\n\r\n### Validation messages\r\n\r\nAnother place where I use conditional types, is to provide custom validation messages to arguments of a function.\r\n\r\n> I don't recommend you add this complexity to your application code, but this could be useful if you maintain a library.\r\n\r\n```jsx\r\ntype Validate<\r\n  Arg,\r\n  ExpectedType,\r\n  ErrorMsg extends string\r\n> = Arg extends ExpectedType ? Arg : ErrorMsg;\r\n\r\nfunction sendMessage<Arg>(\r\n  message: Validate<Arg, string, \"The message must be of type 'string'\">\r\n) {}\r\n\r\n// This won't compile!\r\n// Validate will return the specific type literal:\r\n//  \"The message must be of type 'string'\"\r\nsendMessage(1);\r\n\r\n// compiles without issues:\r\nsendMessage(\"hello\");\r\n```\r\n\r\n## Renaming Fields of an Object\r\n\r\nLet's say you want to create a new object, whose keys are the same as another object, but _in uppercase_.\r\nYou can use the `as` keyword when iterating over fields using `in`, to rename the existing fields:\r\n\r\n```jsx\r\nconst some_constants = {\r\n  max_age: 100,\r\n  minimum_age: 0,\r\n  country_of_residence: \"AU\"\r\n};\r\n\r\ntype SomeConstantsInUppercase = {\r\n  [Property in keyof typeof some_constants as Uppercase<Property>]: typeof some_constants[Property];\r\n}\r\n\r\n// results in:\r\n{\r\n  MAX_AGE: 100,\r\n  MINIMUM_AGE: 0,\r\n  COUNTRY_OF_RESIDENCE: \"AU\"\r\n}\r\n```\r\n\r\nNote: `Uppercase` is another inbuilt TypeScript utility.\r\n\r\n## Using `infer`\r\n\r\n`infer` is something I confess to not understand very well. However I have found it useful when creating more complex types\r\nand I find looking at some examples helpful in understanding how to use it.\r\n\r\n`infer` is used with conditional types in order to extract types in the condition and assign it to another generic variable.\r\nThe golden rule to remember when using `infer` is:\r\n\r\n> `infer` can only be used in the `extends` clause of a _conditional_ type.\r\n\r\nHere's an example where I convert a string from `kebab-case` to `snake_case`:\r\n\r\n```jsx\r\ntype KebabToSnakeCase<S extends string> = S extends `${infer Char}${infer Rest}`\r\n  ? Char extends \"-\"\r\n    ? `_${KebabToSnakeCase<Rest>}`\r\n    : `${Char}${KebabToSnakeCase<Rest>}`\r\n  : S;\r\n\r\ntype Result = KebabToSnakeCase<\"convert-this-kebab-case-to-snake-case\">;\r\n\r\n// Gives: \"convert_this_kebab_case_to_snake_case\"\r\n```\r\n\r\nWhat the following line:\r\n\r\n```jsx\r\nS extends `${infer Char}${infer Rest}`\r\n```\r\n\r\ndoes is that it checks if the generic `S` is a string that is of the template `${Char}${Rest}` - `Char` and `Rest` are named\r\ngeneric variables, and TypeScript will figure out what they are. If the string _does conform_ to it, `Char` will be the\r\nfirst character of a string, while `Rest` will be the remaining characters in the string.\r\n\r\nHere's another example where I extract the value from an object, given the dot-separated path - just like in Lodash's `get` utility:\r\n\r\n```jsx\r\ntype ExtractTypeFromPath<\r\n  Path extends string,\r\n  Object extends Record<string, any>\r\n> = Path extends `${infer Property}.${infer RestOfPath}`\r\n  ? ExtractTypeFromPath<RestOfPath, Object[Property]>\r\n  : Object[Path];\r\n\r\ninterface Person {\r\n  data: {\r\n    firstName: string;\r\n    lastName: string;\r\n    sensitive: {\r\n      age: number;\r\n    };\r\n  };\r\n}\r\n// Results in number\r\ntype TypeOfAge = ExtractTypeFromPath<\"data.sensitive.age\", Person>;\r\n```\r\n\r\n## Dynamically inferring types from JavaScript\r\n\r\nIn the examples so far, we've been dealing exclusively with types - which have no\r\nimpact on the actual execution of our app - after all, the compiler just strips out\r\nall the type definitions.\r\n\r\nHowever, one of the most useful patterns I've found is to derive types from\r\nactual JavaScript objects. The trick is to use `as const` to\r\nensure that the most accurate types would be derived.\r\n\r\nFor example, if you were to do this:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"];\r\n```\r\n\r\n`typeof fieldNames` would give you `string[]`\r\n\r\nHowever, if we did this instead:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\n```\r\n\r\nThis would give you `(\"name\" | \"age\")[]` - which is far more useful. We can then extract the values in the array using:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\ntype FieldName = typeof fieldNames[number];\r\n\r\n// results in: FieldName = \"name\" | \"age\"\r\n```\r\n\r\nA very simplified example of how this can be useful, is when you want to specify in _JavaScript_ what fields a REST API endpoint\r\nshould return.\r\n\r\n```jsx\r\nconst fieldsToFetch = [\"first_name\", \"last_name\", \"dob\", \"country\"] as const;\r\n\r\nasync function someRestAPICall<Fields extends typeof fieldsToFetch>(\r\n    fields: Fields\r\n): Promise<{ [Property in Fields[number]]: string }> {\r\n  // call endpoint and return JSON data\r\n}\r\n\r\nconst response = await someRestAPICall(fieldsToFetch);\r\n\r\n// The type of response would be:\r\n{\r\n  first_name: string;\r\n  last_name: string;\r\n  dob: string;\r\n  country: string;\r\n}\r\n```\r\n\r\nSo if you want to change which fields to request from the REST API, you just update `fieldsToFetch`, and the\r\nresponse would `automatically` update to the correct type.\r\n\r\nFor example, if you removed `\"last_name\"`, and somewhere in the application you referred to `response.last_name`, Typescript will fail to compile with an error!\r\n\r\n> Update: As of Typescript 4.9, you can use the `satisfies` operator to enforce additional type safety when defining `as const` objects. Read this article for more info on `satisfies`: https://www.totaltypescript.com/clarifying-the-satisfies-operator\r\n"},"estimatedReadingTime":{"minutes":9,"words":1142,"text":"9 min read"},"headings":["Creating type safe utility functions","Conditional types","Renaming Fields of an Object","Using `infer`","Dynamically inferring types from JavaScript"]},"__N_SSG":true}