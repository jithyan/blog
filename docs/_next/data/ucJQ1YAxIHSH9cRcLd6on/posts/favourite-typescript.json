{"pageProps":{"post":{"title":"My Current Favourite TypeScript Tips","date":"2022-10-01T20:00:00.000Z","slug":"favourite-typescript","author":{"name":"Jithya Nanayakkara"},"content":"\r\nThis is a small collection of features and patterns I've found useful when working with TypeScript projects. Do note, what I've written is somewhat advanced, and wouldn't be particularly useful unless you already know your way around TypeScript.\r\n\r\n## Creating type safe utility functions\r\n\r\nThere are times when certain libraries or APIs don't have great type definitions, or unexpected types.\r\nAn example of this you may have come across is `Object.keys`, which returns `string[]` rather than the actual keys ([and this is the intended behaviour by the TypeScript authors](https://github.com/Microsoft/TypeScript/issues/12870)).\r\n\r\nWhen you do come across this situation, don't shy away from creating utility functions whose sole purpose is to get better types.\r\nI always create a type safe `Object.keys` helper, and whenever I use the [ImmutableJS](https://immutable-js.com/) library, which has notoriously lousy types, I create separate functions for accessing those objects rather than calling the methods on them directly.\r\n\r\nHere's the helper I use for `Object.keys`:\r\n\r\n```jsx\r\nfunction getObjectKeys<Object extends Record<string, any>>(\r\n  obj: Object\r\n): Array<keyof Object> {\r\n  return Object.keys(obj);\r\n}\r\n```\r\n\r\n## Conditional types\r\n\r\nConditional types essentially allow you to check if a type `A`, is, or is a subset of another type `B`.\r\nYou use it in the form `A extends B ? <true-expression> : <false-expression>`.\r\n\r\nOne example of where I use this, is when I create a `DeepPartial` utility type - the inbuilt `Partial` type only\r\nmakes the fields at the first level of an object optional, however `DeepPartial` makes every field at every level of the object optional:\r\n\r\n```jsx\r\ntype DeepPartial<Object extends Record<string, any>> = {\r\n  [Property in keyof Object]?:\r\n    Object[Property] extends Record<string, any>\r\n      ? DeepPartial<Object[Property]>\r\n      : Object[Property];\r\n};\r\n\r\ninterface Person {\r\n    name: {\r\n      first: string\r\n      last: string;\r\n    }\r\n    age: number\r\n}\r\ntype PartialPerson = DeepPartial<Person>;\r\n\r\n// Results in:\r\n{\r\n  name?: {\r\n    first?: string\r\n    last?: string;\r\n  }\r\n  age?: number\r\n}\r\n```\r\n\r\n1. DeepPartial takes in 1 Generic parameter, `Object`, and we constrain it to be a plain JS object\r\n2. We extract the keys in `Object` using: `keyof Object`\r\n3. We then iterate over every key using the operator `in`, and assign the key to the variable `Property`\r\n4. We add a new field to the resulting object with an optional field: `[Property]?`\r\n5. We check if the value at `Object[Property]` is another object using: `Object[Property] extends Record<string, any> ?`\r\n6. If it is an object, we recursively call `DeepPartial` on it\r\n7. Else, we just return the value at `Object[Property]`\r\n\r\n### Validation messages\r\n\r\nWe can even use conditional types to provide custom validation messages to arguments of a function!\r\n\r\n> I don't recommend you add this complexity to your application code, but this would be useful if you maintain a library.\r\n\r\n```jsx\r\ntype Validate<\r\n  Arg,\r\n  ExpectedType,\r\n  ErrorMsg extends string\r\n> = Arg extends ExpectedType ? Arg : ErrorMsg;\r\n\r\nfunction sendMessage<Arg>(\r\n  message: Validate<Arg, string, \"The message must be of type 'string'\">\r\n) {}\r\n\r\n// This won't compile!\r\n// Validate will return the specific type literal:\r\n//  \"The message must be of type 'string'\"\r\nsendMessage(1);\r\n\r\n// compiles without issues:\r\nsendMessage(\"hello\");\r\n```\r\n\r\n## Renaming Fields of an Object\r\n\r\nLet's say you need to add getter functions to an object, based on the existing fields in it.\r\nYou can use the `as` keyword when iterating over fields using `in`, to rename the existing fields:\r\n\r\n```jsx\r\ntype Getters<Object extends Record<string, any>> = {\r\n  [Property in keyof Object as `get${Capitalize<\r\n    string & Property\r\n  >}`]: () => Object[Property];\r\n};\r\n\r\nconst person = {\r\n  name: \"John\",\r\n  age: 18,\r\n};\r\ntype PersonAsGetters = Getters<typeof person>;\r\n\r\n// results in:\r\n{\r\n  getName: () => string;\r\n  getAge: () => number;\r\n}\r\n```\r\n\r\nNote: `Capitalize` is another inbuilt TypeScript utility.\r\n\r\n## Using `infer`\r\n\r\nYou use `infer` with conditional types in order to extract types to another generic variable.\r\nSeeing this in action would help you understand what the above means better.\r\n\r\n> Remember, we can only use `infer` in the `extends` clause of a conditional type.\r\n\r\nHere's an example where I convert a string from `kebab-case` to `snake_case`:\r\n\r\n```jsx\r\ntype KebabToSnakeCase<S extends string> = S extends `${infer Char}${infer Rest}`\r\n  ? Char extends \"-\"\r\n    ? `_${KebabToSnakeCase<Rest>}`\r\n    : `${Char}${KebabToSnakeCase<Rest>}`\r\n  : S;\r\n\r\ntype Result = KebabToSnakeCase<\"convert-this-kebab-case-to-snake-case\">;\r\n\r\n// results in:\r\n// \"convert_this_kebab_case_to_snake_case\";\r\n```\r\n\r\nWhat the following line:\r\n\r\n```jsx\r\nS extends `${infer Char}${infer Rest}`\r\n```\r\n\r\ndoes is that it checks if the generic `S` is a string that is of the template `${Char}${Rest}` - `Char` and `Rest` are named\r\ngeneric variables, and TypeScript will figure out what they are. If the string _does conform_ to it, `Char` will be the\r\nfirst character of a string, while `Rest` will be the remaining characters in the string.\r\n\r\nHere's another example where I extract the value from an object, given the dot-separated path - just like in Lodash's `get` utility:\r\n\r\n```jsx\r\ntype ExtractTypeFromPath<\r\n  Path extends string,\r\n  Object extends Record<string, any>\r\n> = Path extends `${infer Property}.${infer RestOfPath}`\r\n  ? ExtractTypeFromPath<RestOfPath, Object[Property]>\r\n  : Object[Path];\r\n\r\ninterface Person {\r\n  data: {\r\n    firstName: string;\r\n    lastName: string;\r\n    sensitive: {\r\n      age: number;\r\n    };\r\n  };\r\n}\r\n// Results in number\r\ntype TypeOfAge = ExtractTypeFromPath<\"data.sensitive.age\", Person>;\r\n```\r\n\r\n## Dynamically inferring types from JavaScript\r\n\r\nIn the examples so far, we've been dealing exclusively with types - which have no\r\nimpact on the actual execution of our app - after all, the compiler just strips out\r\nall the type definitions.\r\n\r\nHowever, one of the most useful patterns I've found is to derive types from\r\nactual JavaScript objects. The trick is to use `Readonly` or `as const` to\r\nensure that the most accurate types would be derived.\r\n\r\nFor example, if you were to do this:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"];\r\n```\r\n\r\n`typeof fieldNames` would give you `string[]`\r\n\r\nHowever, if we did this instead:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\n```\r\n\r\nThis would give you `(\"name\" | \"age\")[]` - far more useful. We can then extract the values in the array using:\r\n\r\n```jsx\r\nconst fieldNames = [\"name\", \"age\"] as const;\r\ntype FieldName = typeof fieldNames[number];\r\n\r\n// results in: FieldName = \"name\" | \"age\"\r\n```\r\n\r\nBelow is an example of a situation where I used this approach. I needed to make a GET request\r\nto a REST API, and I could specify what fields in the data I want returned in the response. I simply\r\nhad to pass the field names as query parameters in the URL.\r\n\r\nRather than putting the field names as query parameters in a hard to read URL, I decided to put the fields I want\r\nin an array, then convert the array to the appropriate query parameters.\r\n\r\nHowever, TypeScript types become an issue - how does it know what the response object type is\r\nwhen it could change depending on what I put in the Javascript array?\r\n\r\nThis is how I did it:\r\n\r\n```jsx\r\nconst pickFields = [\"age\", \"name\", \"height\", \"isMember\"] as const;\r\n\r\ninterface ApiResponse {\r\n  age: number;\r\n  name: {\r\n    firstName: string;\r\n    lastName: string;\r\n  };\r\n  height: string;\r\n  isMember: boolean;\r\n}\r\n// Note that I'm not specifying pickFields is of type \"Array<keyof ApiResponse>\"!\r\n\r\nasync function getPersonDetails<\r\n  RequestedFields extends ReadonlyArray<typeof pickFields[number]>\r\n>(\r\n  ...fieldNames: RequestedFields\r\n): Promise<{\r\n  [Field in RequestedFields extends ReadonlyArray<infer FieldNameValue>\r\n    ? FieldNameValue\r\n    : never]: ApiResponse[Field];\r\n}> {\r\n  return callRestApi(\"/v1/person\", fieldNames) as any;\r\n}\r\n\r\n// Will give you { age: number; isMember: boolean; height: string}\r\nconst response = await getPersonDetails(\"age\", \"isMember\", \"height\");\r\n```\r\n\r\nThis is the really cool part of making `pickFields` a `const` - TypeScript\r\ncan figure out from the signature of `getPersonDetails` that the values in\r\n`pickFields` **are a member of** `ApiResponse`!\r\n\r\nIf we put the string \"woof\" into `pickFields`, `getPersonDetails` will fail compilation with an error, because \"woof\" is not a field in `ApiResponse`!\r\n\r\nAnd if we put \"meow\" into the arguments of `getPersonDetails`, it will also fail for the same reason.\r\n"},"estimatedReadingTime":{"minutes":10,"words":1256,"text":"10 min read"}},"__N_SSG":true}